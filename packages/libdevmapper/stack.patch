Fixes errors like:
/storage/termux-build/_cache/android-r21d-api-24-v3/bin/../sysroot/usr/include/linux/sched.h:53:17: error: expected parameter declarator
  __aligned_u64 stack;

There's probably a better way to fix this. This patch will be annoying to maintain..

diff -u -r ../src.orig/daemons/dmeventd/dmeventd.c ./daemons/dmeventd/dmeventd.c
--- ../src.orig/daemons/dmeventd/dmeventd.c	2020-08-03 10:42:24.468850261 +0200
+++ ./daemons/dmeventd/dmeventd.c	2020-08-03 10:42:34.530533401 +0200
@@ -726,7 +726,7 @@
 				message_data->id, getpid(),
 				_foreground ? "no" : "yes",
 				_systemd_activation ? "systemd" : "direct")) < 0) {
-		stack;
+		log_stack;
 		return -ENOMEM;
 	}
 
@@ -1171,7 +1171,7 @@
 
 	if (!(dso_data = _lookup_dso(message_data)) &&
 	    !(dso_data = _load_dso(message_data))) {
-		stack;
+		log_stack;
 #ifdef ELIBACC
 		ret = ELIBACC;
 #else
@@ -1191,12 +1191,12 @@
 		/* Only creating thread during event processing
 		 * Remaining initialization happens within monitoring thread */
 		if (!(thread = _alloc_thread_status(message_data, dso_data))) {
-			stack;
+			log_stack;
 			return -ENOMEM;
 		}
 
 		if ((ret = _create_thread(thread))) {
-			stack;
+			log_stack;
 			_free_thread_status(thread);
 			return -ret;
 		}
@@ -1216,7 +1216,7 @@
 	   almost as good as dead already... */
 	if ((message_data->events_field & DM_EVENT_TIMEOUT) &&
 	    (ret = _register_for_timeout(thread))) {
-		stack;
+		log_stack;
 		_unregister_for_event(message_data);
 	}
 
@@ -1631,7 +1631,7 @@
 			free(answer);
 		}
 	} else if (msg->cmd != DM_EVENT_CMD_ACTIVE && !_parse_message(&message_data)) {
-		stack;
+		log_stack;
 		ret = -EINVAL;
 	} else
 		ret = _handle_request(msg, &message_data);
@@ -1666,7 +1666,7 @@
 	_do_process_request(&msg);
 
 	if (!_client_write(fifos, &msg))
-		stack;
+		log_stack;
 
 	DEBUGLOG("<<< CMD:%s (0x%x) completed (result %d).", decode_cmd(cmd), cmd, msg.cmd);
 
diff -u -r ../src.orig/daemons/dmeventd/libdevmapper-event.c ./daemons/dmeventd/libdevmapper-event.c
--- ../src.orig/daemons/dmeventd/libdevmapper-event.c	2020-08-03 10:42:24.468850261 +0200
+++ ./daemons/dmeventd/libdevmapper-event.c	2020-08-03 10:42:34.533868398 +0200
@@ -379,7 +379,7 @@
 	 * read status return code from daemon.
 	 */
 	if (!_daemon_write(fifos, msg)) {
-		stack;
+		log_stack;
 		free(msg->data);
 		msg->data = NULL;
 		return -EIO;
@@ -390,7 +390,7 @@
 		msg->data = NULL;
 
 		if (!_daemon_read(fifos, msg)) {
-			stack;
+			log_stack;
 			return -EIO;
 		}
 	} while (!_check_message_id(msg));
diff -u -r ../src.orig/daemons/dmeventd/plugins/thin/dmeventd_thin.c ./daemons/dmeventd/plugins/thin/dmeventd_thin.c
--- ../src.orig/daemons/dmeventd/plugins/thin/dmeventd_thin.c	2020-08-03 10:42:24.468850261 +0200
+++ ./daemons/dmeventd/plugins/thin/dmeventd_thin.c	2020-08-03 10:42:34.573888351 +0200
@@ -185,7 +185,7 @@
 		if (_use_policy(dmt, state))
 			goto out;
 
-		stack;
+		log_stack;
 
 		/*
 		 * Rather update oldish status
diff -u -r ../src.orig/daemons/dmeventd/plugins/vdo/dmeventd_vdo.c ./daemons/dmeventd/plugins/vdo/dmeventd_vdo.c
--- ../src.orig/daemons/dmeventd/plugins/vdo/dmeventd_vdo.c	2020-08-03 10:42:24.468850261 +0200
+++ ./daemons/dmeventd/plugins/vdo/dmeventd_vdo.c	2020-08-03 10:42:34.580558342 +0200
@@ -177,7 +177,7 @@
 		if (_use_policy(dmt, state))
 			goto out;
 
-		stack;
+		log_stack;
 
 		if (!(new_dmt = dm_task_create(DM_DEVICE_STATUS)))
 			goto_out;
diff -u -r ../src.orig/device_mapper/ioctl/libdm-iface.c ./device_mapper/ioctl/libdm-iface.c
--- ../src.orig/device_mapper/ioctl/libdm-iface.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/ioctl/libdm-iface.c	2020-08-03 10:42:34.677273229 +0200
@@ -559,7 +559,7 @@
 
 	r = dm_task_run(task);
 	if (!dm_task_get_driver_version(task, version, size))
-		stack;
+		log_stack;
 	dm_task_destroy(task);
 	_log_suppress = 0;
 
@@ -1319,12 +1319,12 @@
 			continue;
 		if (!dm_task_set_name(dmt, dirent->d_name)) {
 			r = 0;
-			stack;
+			log_stack;
 			continue; /* try next name */
 		}
 		if (!dm_task_run(dmt)) {
 			r = 0;
-			stack;  /* keep going */
+			log_stack;  /* keep going */
 		}
 	}
 
@@ -1446,14 +1446,14 @@
 
 	/* Next load the table */
 	if (!(task = dm_task_create(DM_DEVICE_RELOAD))) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
 
 	/* Copy across relevant fields */
 	if (dmt->dev_name && !dm_task_set_name(task, dmt->dev_name)) {
-		stack;
+		log_stack;
 		dm_task_destroy(task);
 		_udev_complete(dmt);
 		goto revert;
@@ -1471,7 +1471,7 @@
 	dm_task_destroy(task);
 
 	if (!r) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
@@ -1505,7 +1505,7 @@
 		if (!dm_task_set_cookie(dmt, &cookie,
 					(dmt->event_nr & DM_UDEV_FLAGS_MASK) >>
 					DM_UDEV_FLAGS_SHIFT))
-			stack; /* keep going */
+			log_stack; /* keep going */
 	}
 
 	if (!dm_task_run(dmt))
@@ -1878,7 +1878,7 @@
 
 	if (dmt->record_timestamp)
 		if (!dm_timestamp_get(_dm_ioctl_timestamp))
-			stack;
+			log_stack;
 
 	if (r < 0 && dmt->expected_errno != errno) {
 		dmt->ioctl_errno = errno;
diff -u -r ../src.orig/device_mapper/libdm-common.c ./device_mapper/libdm-common.c
--- ../src.orig/device_mapper/libdm-common.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/libdm-common.c	2020-08-03 10:42:34.683943220 +0200
@@ -1811,7 +1811,7 @@
 	while (!feof(minfo) && fgets(buffer, sizeof(buffer), minfo))
 		if (!_mountinfo_parse_line(buffer, &maj, &min, target) ||
 		    !read_fn(buffer, maj, min, target, cb_data)) {
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
@@ -2056,7 +2056,7 @@
 		if (_sysfs_get_dm_name(major, minor, buf, buf_size))
 			return 1;
 		else
-			stack;
+			log_stack;
 	}
 
 	/*
@@ -2150,7 +2150,7 @@
 	if ((major == data->maj) && (minor == data->min)) {
 		if (!dm_device_get_name(major, minor, 1, kernel_dev_name,
 					sizeof(kernel_dev_name))) {
-			stack;
+			log_stack;
 			*kernel_dev_name = '\0';
 		}
 		log_verbose("Device %s (%u:%u) appears to be mounted on %s.",
@@ -2170,7 +2170,7 @@
 	};
 
 	if (!dm_mountinfo_read(_device_has_mounted_fs, &data))
-		stack;
+		log_stack;
 
 	if (data.mounted)
 		return 1;
@@ -2573,7 +2573,7 @@
 			     gen_cookie, gen_semid, val);
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*semid = gen_semid;
 	*cookie = gen_cookie;
@@ -2582,7 +2582,7 @@
 
 bad:
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*cookie = 0;
 
diff -u -r ../src.orig/device_mapper/libdm-deptree.c ./device_mapper/libdm-deptree.c
--- ../src.orig/device_mapper/libdm-deptree.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/libdm-deptree.c	2020-08-03 10:42:34.687278217 +0200
@@ -634,7 +634,7 @@
 			"%s (" FMTu32 ":" FMTu32 ")",
 			dnode->name ? dnode->name : "",
 			dnode->info.major, dnode->info.minor) < 0) {
-		stack;
+		log_stack;
 		return dnode->name;
 	}
 
@@ -759,7 +759,7 @@
 
 	dm_list_iterate_items(dlink, list) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -978,7 +978,7 @@
 	/* Iterate through parents of this node */
 	dm_list_iterate_items(dlink, &node->used_by) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1241,7 +1241,7 @@
 	/* Can't recurse if not a mapped device or there are no dependencies */
 	if (!node->info.exists || !deps || !deps->count) {
 		if (!_add_to_bottomlevel(node)) {
-			stack;
+			log_stack;
 			node = NULL;
 		}
 		goto out;
@@ -1355,7 +1355,7 @@
 		dec_suspended();
 
 	if (!(r = dm_task_get_info(dmt, newinfo)))
-		stack;
+		log_stack;
 
 out:
 	dm_task_destroy(dmt);
@@ -1739,17 +1739,17 @@
 
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1784,7 +1784,7 @@
 
 			/* Check toplevel node for holders/mounted fs */
 			if (!_check_device_not_in_use(name, &info)) {
-				stack;
+				log_stack;
 				r = 0;
 				continue;
 			}
@@ -1824,7 +1824,7 @@
 		if (child->callback &&
 		    !child->callback(child, DM_NODE_CALLBACK_DEACTIVATED,
 				     child->callback_data))
-			stack;
+			log_stack;
 			/* FIXME Deactivation must currently ignore failure
 			 * here so that lvremove can continue: we need an
 			 * alternative way to handle this state without 
@@ -1861,17 +1861,17 @@
 	/* Suspend nodes at this level of the tree */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1892,7 +1892,7 @@
 		/* If child has some real messages send them */
 		if ((child->props.send_messages > 1) && r) {
 			if (!(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 			else {
 				log_debug_activation("Sent messages to thin-pool %s and "
 						     "skipping suspend of its children.",
@@ -1923,7 +1923,7 @@
 			continue;
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1971,7 +1971,7 @@
 			continue;
 
 		if (!(sibling_name = dm_tree_node_get_name(sibling))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2000,7 +2000,7 @@
 	/* Activate children first */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -2021,7 +2021,7 @@
 				continue;
 
 			if (!(uuid = dm_tree_node_get_uuid(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -2029,7 +2029,7 @@
 				continue;
 
 			if (!(name = dm_tree_node_get_name(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -2072,7 +2072,7 @@
 			 */
 			if (r && (child->props.send_messages > 1) &&
 			    !(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 		}
 		if (awaiting_peer_rename)
 			priority--; /* redo priority level */
@@ -2179,7 +2179,7 @@
 do {\
 	int w;\
 	if ((w = dm_snprintf(params + p, paramsize - (size_t) p, str)) < 0) {\
-		stack; /* Out of space */\
+		log_stack; /* Out of space */\
 		return -1;\
 	}\
 	p += w;\
@@ -2906,7 +2906,7 @@
 	case SEG_LINEAR:
 	case SEG_STRIPED:
 		if ((r = _emit_areas_line(dmt, seg, params, paramsize, &pos)) <= 0) {
-			stack;
+			log_stack;
 			return r;
 		}
 		if (!params[0]) {
@@ -2954,7 +2954,7 @@
 		free(params);
 
 		if (!ret)
-			stack;
+			log_stack;
 
 		if (ret >= 0)
 			return ret;
@@ -3128,7 +3128,7 @@
 				if (!_remove_node(child))
 					return_0;
 				if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-					stack;
+					log_stack;
 				dm_tree_set_cookie(dnode, 0);
 				(void) _dm_tree_revert_activated(child);
 			}
@@ -3164,9 +3164,9 @@
 			/* When creating new node also check transaction_id. */
 			if (child->props.send_messages &&
 			    !_node_send_messages(child, uuid_prefix, uuid_prefix_len, 0)) {
-				stack;
+				log_stack;
 				if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-					stack;
+					log_stack;
 				dm_tree_set_cookie(dnode, 0);
 				(void) _dm_tree_revert_activated(dnode);
 				r = 0;
@@ -3186,7 +3186,7 @@
 	if (update_devs_flag ||
 	    (r && !dnode->info.exists && dnode->callback)) {
 		if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-			stack;
+			log_stack;
 		dm_tree_set_cookie(dnode, 0);
 
 		if (r && !dnode->info.exists && dnode->callback &&
diff -u -r ../src.orig/device_mapper/libdm-file.c ./device_mapper/libdm-file.c
--- ../src.orig/device_mapper/libdm-file.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/libdm-file.c	2020-08-03 10:42:34.690613212 +0200
@@ -252,12 +252,12 @@
                log_error("Cannot check lock status of lockfile [%s], error was [%s]",
                          lockfile, strerror(errno));
                if (close(fd))
-                       stack;
+                       log_stack;
                return 0;
        }
 
        if (close(fd))
-               stack;
+               log_stack;
 
        return (lock.l_type == F_UNLCK) ? 0 : 1;
 }
diff -u -r ../src.orig/device_mapper/libdm-report.c ./device_mapper/libdm-report.c
--- ../src.orig/device_mapper/libdm-report.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/libdm-report.c	2020-08-03 10:42:34.693948209 +0200
@@ -835,7 +835,7 @@
 	}
 
 	if (!_copy_field(rh, fp, field_num, implicit)) {
-		stack;
+		log_stack;
 		dm_pool_free(rh->mem, fp);
 		return NULL;
 	}
diff -u -r ../src.orig/device_mapper/libdm-timestamp.c ./device_mapper/libdm-timestamp.c
--- ../src.orig/device_mapper/libdm-timestamp.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/libdm-timestamp.c	2020-08-03 10:42:34.697283205 +0200
@@ -55,7 +55,7 @@
 	struct dm_timestamp *ts = NULL;
 
 	if (!(ts = zalloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
@@ -103,7 +103,7 @@
 	struct dm_timestamp *ts;
 
 	if (!(ts = malloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
diff -u -r ../src.orig/device_mapper/regex/parse_rx.c ./device_mapper/regex/parse_rx.c
--- ../src.orig/device_mapper/regex/parse_rx.c	2020-08-03 10:42:24.442170294 +0200
+++ ./device_mapper/regex/parse_rx.c	2020-08-03 10:42:34.717293181 +0200
@@ -377,7 +377,7 @@
 		return l;
 
 	if (!(n = _node(ps->mem, CAT, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
@@ -400,7 +400,7 @@
 	}
 
 	if (!(n = _node(ps->mem, OR, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
diff -u -r ../src.orig/lib/activate/activate.c ./lib/activate/activate.c
--- ../src.orig/lib/activate/activate.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/activate/activate.c	2020-08-03 10:42:34.810673071 +0200
@@ -870,7 +870,7 @@
 		log_debug_activation("Retrying open_count check for %s.",
 				     display_lvname(lv));
 		if (!lv_info(lv->vg->cmd, lv, 0, &info, 1, 0)) {
-			stack; /* device dissappeared? */
+			log_stack; /* device dissappeared? */
 			break;
 		}
 	}
@@ -896,7 +896,7 @@
 		return_0;
 
 	if (!(r = dev_manager_transient(dm, lv)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -921,7 +921,7 @@
 		return_0;
 
 	if (!(r = dev_manager_snapshot_percent(dm, lv, percent)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -952,7 +952,7 @@
 		return_0;
 
 	if (!(r = dev_manager_mirror_percent(dm, lv, wait, percent, event_nr)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1268,7 +1268,7 @@
 		return_0;
 
 	if (!(r = dev_manager_thin_pool_percent(dm, lv, metadata, percent)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1294,7 +1294,7 @@
 		return_0;
 
 	if (!(r = dev_manager_thin_percent(dm, lv, mapped, percent)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1321,7 +1321,7 @@
 		return_0;
 
 	if (!(r = dev_manager_thin_pool_status(dm, lv, &status, 0)))
-		stack;
+		log_stack;
 	else
 		*transaction_id = status->transaction_id;
 
@@ -1345,7 +1345,7 @@
 		return_0;
 
 	if (!(r = dev_manager_thin_device_id(dm, lv, device_id)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1418,7 +1418,7 @@
 	struct lvinfo info;
 
 	if (!lv_info(cmd, lv, 0, &info, 1, 0)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
@@ -1434,7 +1434,7 @@
 		return_0;
 
 	if (!(r = dev_manager_activate(dm, lv, laopts)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1453,7 +1453,7 @@
 	laopts->read_only = _passes_readonly_filter(lv->vg->cmd, lv);
 
 	if (!(r = dev_manager_preload(dm, lv, laopts, flush_required)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 
@@ -1471,7 +1471,7 @@
 		return_0;
 
 	if (!(r = dev_manager_deactivate(dm, lv)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1493,7 +1493,7 @@
 		return_0;
 
 	if (!(r = dev_manager_suspend(dm, lv, laopts, lockfs, flush_required)))
-		stack;
+		log_stack;
 
 	dev_manager_destroy(dm);
 	return r;
@@ -1834,7 +1834,7 @@
 	if (lv_is_cow(lv) && (laopts->no_merging || !lv_is_merging_cow(lv) ||
 			      lv_has_target_type(lv->vg->cmd->mem, lv, NULL, TARGET_NAME_SNAPSHOT))) {
 		if (!(r = monitor_dev_for_events(cmd, lv->snapshot->lv, NULL, monitor)))
-			stack;
+			log_stack;
 		return r;
 	}
 
@@ -1848,7 +1848,7 @@
 		dm_list_iterate_safe(snh, snht, &lv->snapshot_segs)
 			if (!monitor_dev_for_events(cmd, dm_list_struct_base(snh,
 				struct lv_segment, origin_list)->cow, NULL, monitor)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 
@@ -1860,7 +1860,7 @@
 	    (log_seg = first_seg(seg->log_lv)) != NULL &&
 	    seg_is_mirrored(log_seg))
 		if (!monitor_dev_for_events(cmd, seg->log_lv, NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -1871,7 +1871,7 @@
 				continue;
 			if (!monitor_dev_for_events(cmd, seg_lv(seg, s), NULL,
 						    monitor)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 		}
@@ -1884,20 +1884,20 @@
 		if (seg->pool_lv &&
 		    !monitor_dev_for_events(cmd, seg->pool_lv,
 					    (!monitor) ? laopts : NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
 		if (seg->external_lv &&
 		    !monitor_dev_for_events(cmd, seg->external_lv,
 					    (!monitor) ? laopts : NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
 		if (seg->metadata_lv &&
 		    !monitor_dev_for_events(cmd, seg->metadata_lv, NULL, monitor)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -1978,7 +1978,7 @@
 			 * so they skip this dm mirror table refreshing step.
 			 */
 			if (!_lv_activate_lv(lv, &mirr_laopts)) {
-				stack;
+				log_stack;
 				r = 0;
 			}
 		}
@@ -1988,7 +1988,7 @@
 		for (i = 0;; i++) {
 			pending = 0;
 			if (!seg->segtype->ops->target_monitored(seg, &pending, &monitored)) {
-				stack;
+				log_stack;
 				r = 0;
 				break;
 			}
@@ -2184,7 +2184,7 @@
 
 	if (!monitor_dev_for_events(cmd, lv, laopts, 0))
 		/* FIXME Consider aborting here */
-		stack;
+		log_stack;
 
 	if (!laopts->origin_only &&
 	    (lv_is_origin(lv_pre) || lv_is_cow(lv_pre)))
@@ -2359,7 +2359,7 @@
 	critical_section_dec(cmd, "resumed");
 
 	if (!monitor_dev_for_events(cmd, lv, laopts, 1))
-		stack;
+		log_stack;
 
 	r = 1;
 out:
@@ -2472,7 +2472,7 @@
 	}
 
 	if (!monitor_dev_for_events(cmd, lv, &laopts, 0))
-		stack;
+		log_stack;
 
 	critical_section_inc(cmd, "deactivating");
 	r = _lv_deactivate(lv);
@@ -2600,11 +2600,11 @@
 
 	critical_section_inc(cmd, "activating");
 	if (!(r = _lv_activate_lv(lv, laopts)))
-		stack;
+		log_stack;
 	critical_section_dec(cmd, "activated");
 
 	if (r && !monitor_dev_for_events(cmd, lv, laopts, 1))
-		stack;
+		log_stack;
 out:
 	return r;
 }
diff -u -r ../src.orig/lib/activate/dev_manager.c ./lib/activate/dev_manager.c
--- ../src.orig/lib/activate/dev_manager.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/activate/dev_manager.c	2020-08-03 10:42:34.814008067 +0200
@@ -311,7 +311,7 @@
 
 		if (!target_name ||
 		    !_get_segment_status_from_target_params(target_name, target_params, seg_status))
-			stack;
+			log_stack;
 	}
 
 	r = 1;
@@ -398,7 +398,7 @@
 					       .check_error_target = 1,
 					       .check_reserved = 0 }))
 				goto out; /* safe to use */
-			stack;
+			log_stack;
 		}
 	}
 
@@ -564,7 +564,7 @@
 		return_0;
 
 	if (!dm_get_status_snapshot(mem, params, &s))
-		stack;
+		log_stack;
         else
 		r = s->invalid;
 
@@ -583,7 +583,7 @@
 		return_0;
 
 	if (!dm_get_status_raid(mem, params, &s))
-		stack;
+		log_stack;
 	else if (s->sync_action && !strcmp(s->sync_action, "frozen")) {
 		log_warn("WARNING: %s frozen raid device (%d:%d) needs inspection.",
 			  dev_name(dev), (int)MAJOR(dev->dev), (int)MINOR(dev->dev));
@@ -908,7 +908,7 @@
 	if (!(r = _info(cmd, name, dlid,
 			with_open_count, with_read_ahead, with_name_check,
 			dminfo, read_ahead, seg_status)))
-		stack;
+		log_stack;
 out:
 	dm_pool_free(cmd->mem, name);
 
diff -u -r ../src.orig/lib/activate/fs.c ./lib/activate/fs.c
--- ../src.orig/lib/activate/fs.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/activate/fs.c	2020-08-03 10:42:34.817343063 +0200
@@ -286,10 +286,10 @@
 	case FS_RENAME:
 		if (old_lv_name && !_rm_link(dev_dir, vg_name, old_lv_name,
 					     check_udev))
-			stack;
+			log_stack;
 
 		if (!_mk_link(dev_dir, vg_name, lv_name, dev, check_udev))
-			stack;
+			log_stack;
 	default:
 		; /* NOTREACHED */
 	}
@@ -492,7 +492,7 @@
 		log_debug_activation("Syncing device names");
 		/* Wait for all processed udev devices */
 		if (!dm_udev_wait(_fs_cookie))
-			stack;
+			log_stack;
 		_fs_cookie = DM_COOKIE_AUTO_CREATE; /* Reset cookie */
 		dm_lib_release();
 		_pop_fs_ops();
diff -u -r ../src.orig/lib/cache/lvmcache.c ./lib/cache/lvmcache.c
--- ../src.orig/lib/cache/lvmcache.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/cache/lvmcache.c	2020-08-03 10:42:34.824013055 +0200
@@ -476,7 +476,7 @@
 
 	dm_list_iterate_items(devl, &_unused_duplicates) {
 		if (!id_write_format((const struct id *)devl->dev->pvid, uuid, sizeof(uuid)))
-			stack;
+			log_stack;
 
 		log_warn("WARNING: Not using device %s for PV %s.", dev_name(devl->dev), uuid);
 	}
@@ -487,7 +487,7 @@
 			continue;
 
 		if (!id_write_format((const struct id *)info->dev->pvid, uuid, sizeof(uuid)))
-			stack;
+			log_stack;
 
 		log_warn("WARNING: PV %s prefers device %s because %s.",
 			 uuid, dev_name(info->dev), info->dev->duplicate_prefer_reason);
@@ -1943,7 +1943,7 @@
 	(void) dm_strncpy(pvid_s, pvid, sizeof(pvid_s));
 
 	if (!id_write_format((const struct id *)&pvid_s, uuid, sizeof(uuid)))
-		stack;
+		log_stack;
 
 	/*
 	 * Find existing info struct in _pvid_hash or create a new one.
@@ -2070,7 +2070,7 @@
 	do {
 		next = vginfo->next;
 		if (!_free_vginfo(vginfo))
-			stack;
+			log_stack;
 	} while ((vginfo = next));
 }
 
@@ -2119,11 +2119,11 @@
 		struct format_type *fmt;
 
 		if (!lvmcache_init(cmd))
-			stack;
+			log_stack;
 
 		dm_list_iterate_items(fmt, &cmd->formats) {
 			if (!lvmcache_add_orphan_vginfo(fmt->orphan_vg_name, fmt))
-				stack;
+				log_stack;
 		}
 	}
 }
diff -u -r ../src.orig/lib/commands/toolcontext.c ./lib/commands/toolcontext.c
--- ../src.orig/lib/commands/toolcontext.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/commands/toolcontext.c	2020-08-03 10:42:34.827348051 +0200
@@ -123,7 +123,7 @@
 	free(line);
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	return system_id;
 }
@@ -1805,7 +1805,7 @@
 
 	_destroy_filters(cmd);
 	if (!(r = init_filters(cmd, 0)))
-                stack;
+                log_stack;
 
 	/*
 	 * During repair code must not reset suspended flag.
@@ -1837,7 +1837,7 @@
 	_destroy_formats(cmd, &cmd->formats);
 
 	if (!dev_cache_exit())
-		stack;
+		log_stack;
 	_destroy_dev_types(cmd);
 	_destroy_tags(cmd);
 
diff -u -r ../src.orig/lib/config/config.c ./lib/config/config.c
--- ../src.orig/lib/config/config.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/config/config.c	2020-08-03 10:42:34.834018043 +0200
@@ -253,7 +253,7 @@
 		cf = cs->source.file;
 		if (cf && cf->dev)
 			if (!dev_close(cf->dev))
-				stack;
+				log_stack;
 	}
 
 	dm_config_destroy(cft);
@@ -619,7 +619,7 @@
 
 	if (!cf->keep_open) {
 		if (!dev_close(cf->dev))
-			stack;
+			log_stack;
 		cf->dev = NULL;
 	}
 
@@ -1918,7 +1918,7 @@
 	}
 
 	if (baton.fp && baton.fp != stdout && dm_fclose(baton.fp)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -2474,7 +2474,7 @@
 
 	if (!get_default_allocation_thin_pool_chunk_size(cmd, profile, &chunk_size,
 							 &chunk_size_calc_method)) {
-		stack; /* Ignore this error, never happens... */
+		log_stack; /* Ignore this error, never happens... */
 		chunk_size = DEFAULT_THIN_POOL_CHUNK_SIZE * 2;
 	}
 
diff -u -r ../src.orig/lib/device/bcache.c ./lib/device/bcache.c
--- ../src.orig/lib/device/bcache.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/bcache.c	2020-08-03 10:42:35.234217572 +0200
@@ -1156,7 +1156,7 @@
 		log_warn("some blocks are still locked");
 
 	if (!bcache_flush(cache))
-		stack;
+		log_stack;
 	_wait_all(cache);
 	_exit_free_list(cache);
 	radix_tree_destroy(cache->rtree);
diff -u -r ../src.orig/lib/device/dev-cache.c ./lib/device/dev-cache.c
--- ../src.orig/lib/device/dev-cache.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/dev-cache.c	2020-08-03 10:42:35.314257479 +0200
@@ -1302,7 +1302,7 @@
 				  dev_name(dev), dev->open_count);
 			num_open++;
 			if (close_immediate && !dev_close_immediate(dev))
-				stack;
+				log_stack;
 		}
 	}
 
diff -u -r ../src.orig/lib/device/dev-dasd.c ./lib/device/dev-dasd.c
--- ../src.orig/lib/device/dev-dasd.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/dev-dasd.c	2020-08-03 10:42:35.370952411 +0200
@@ -96,7 +96,7 @@
 
 out:
 	if (!dev_close(dev))
-		stack;
+		log_stack;
 
 	return ret;
 }
diff -u -r ../src.orig/lib/device/dev-io.c ./lib/device/dev-io.c
--- ../src.orig/lib/device/dev-io.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/dev-io.c	2020-08-03 10:42:35.464332301 +0200
@@ -136,7 +136,7 @@
 	if (ioctl(dev->fd, BLKRAGET, &read_ahead_long) < 0) {
 		log_sys_error("ioctl BLKRAGET", dev_name(dev));
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		return 0;
 	}
 
@@ -147,7 +147,7 @@
 			 dev_name(dev), *read_ahead);
 
 	if (!dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -170,13 +170,13 @@
 		log_error("%s: BLKDISCARD ioctl at offset %" PRIu64 " size %" PRIu64 " failed: %s.",
 			  dev_name(dev), offset_bytes, size_bytes, strerror(errno));
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		/* It doesn't matter if discard failed, so return success. */
 		return 1;
 	}
 
 	if (!dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -209,7 +209,7 @@
 	 * without reverting to read-modify-write operations"
 	 */
 	if (ioctl(fd, BLKPBSZGET, &pbs)) {
-		stack;
+		log_stack;
 		pbs = 0;
 	}
 #endif
@@ -219,7 +219,7 @@
 	 * "the lowest possible block size that the storage device can address."
 	 */
 	if (ioctl(fd, BLKSSZGET, &lbs)) {
-		stack;
+		log_stack;
 		lbs = 0;
 	}
 
@@ -230,7 +230,7 @@
 	*logical_block_size = lbs;
 
 	if (do_close && !dev_close_immediate(dev))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -397,7 +397,7 @@
 	    ((fstat(dev->fd, &buf) < 0) || (buf.st_rdev != dev->dev))) {
 		log_error("%s: fstat failed: Has device name changed?", name);
 		if (!dev_close_immediate(dev))
-			stack;
+			log_stack;
 		return 0;
 	}
 
diff -u -r ../src.orig/lib/device/dev-md.c ./lib/device/dev-md.c
--- ../src.orig/lib/device/dev-md.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/dev-md.c	2020-08-03 10:42:35.561047189 +0200
@@ -138,7 +138,7 @@
 		return -EAGAIN;
 
 	if (!dev_get_size(dev, &size)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
diff -u -r ../src.orig/lib/device/dev-swap.c ./lib/device/dev-swap.c
--- ../src.orig/lib/device/dev-swap.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/device/dev-swap.c	2020-08-03 10:42:35.594397149 +0200
@@ -46,7 +46,7 @@
 		return -EAGAIN;
 
 	if (!dev_get_size(dev, &size)) {
-		stack;
+		log_stack;
 		return -1;
 	}
 
diff -u -r ../src.orig/lib/display/display.c ./lib/display/display.c
--- ../src.orig/lib/display/display.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/display/display.c	2020-08-03 10:42:35.721126999 +0200
@@ -210,7 +210,7 @@
 		return;
 
 	if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -267,7 +267,7 @@
 		return;
 
 	if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -780,7 +780,7 @@
 		  display_size(vg->cmd, vg_free(vg)));
 
 	if (!id_write_format(&vg->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -811,7 +811,7 @@
 	}
 
 	if (!id_write_format(&vg->id, uuid, sizeof(uuid))) {
-		stack;
+		log_stack;
 		return;
 	}
 
@@ -997,7 +997,7 @@
 
 	/* For other then Yes answer check there is really no interrupt */
 	if (sig || sigint_caught()) {
-		stack;
+		log_stack;
 		ret = 'n';
 	} else if (c == EOF) {
 		fputs("[n]\n", stderr);
diff -u -r ../src.orig/lib/format_text/archiver.c ./lib/format_text/archiver.c
--- ../src.orig/lib/format_text/archiver.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/format_text/archiver.c	2020-08-03 10:42:35.754476959 +0200
@@ -316,7 +316,7 @@
 
 	dm_list_iterate_items(mda, &tf->metadata_areas_in_use) {
 		if (!(vg = mda->ops->vg_read(tf, vg_name, mda, NULL, NULL)))
-			stack;
+			log_stack;
 		break;
 	}
 
@@ -589,12 +589,12 @@
 	/* Write and commit the metadata area */
 	dm_list_iterate_items(mda, &tf->metadata_areas_in_use) {
 		if (!(r = mda->ops->vg_write(tf, vg, mda))) {
-			stack;
+			log_stack;
 			continue;
 		}
 		if (mda->ops->vg_commit &&
 		    !(r = mda->ops->vg_commit(tf, vg, mda))) {
-			stack;
+			log_stack;
 		}
 	}
 
@@ -642,11 +642,11 @@
 
 	if (vg_backup) {
 		if (!_archive(vg_backup, 0))
-			stack;
+			log_stack;
 		release_vg(vg_backup);
 	}
 	if (!_archive(vg, 0))
-		stack;
+		log_stack;
 	if (!backup_locally(vg))
-		stack;
+		log_stack;
 }
diff -u -r ../src.orig/lib/format_text/format-text.c ./lib/format_text/format-text.c
--- ../src.orig/lib/format_text/format-text.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/format_text/format-text.c	2020-08-03 10:42:35.761146952 +0200
@@ -370,7 +370,7 @@
 
 	if ((info = lvmcache_info_from_pvid(dev_area->dev->pvid, dev_area->dev, 0)) &&
 	    !lvmcache_update_vgname_and_id(info, &vgsummary_orphan))
-		stack;
+		log_stack;
 
 	return NULL;
 }
@@ -1546,7 +1546,7 @@
 	memset(namebuf, 0, sizeof(namebuf));
 
 	if (!dev_read_bytes(dev_area->dev, dev_area->start + rlocn->offset, NAME_LEN, namebuf))
-		stack;
+		log_stack;
 
 	while (namebuf[len] && !isspace(namebuf[len]) && namebuf[len] != '{' &&
 	       len < (NAME_LEN - 1))
@@ -1795,7 +1795,7 @@
 		return_0;
 
 	if (!label_write(pv->dev, label)) {
-		stack;
+		log_stack;
 		return 0;
 	}
 
diff -u -r ../src.orig/lib/format_text/import.c ./lib/format_text/import.c
--- ../src.orig/lib/format_text/import.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/format_text/import.c	2020-08-03 10:42:35.767816944 +0200
@@ -229,7 +229,7 @@
 		 * so it can use cached PV state too.
 		 */
 		if (!(vg = (*vsn)->read_vg(cmd, fid->fmt, fid, cft)))
-			stack;
+			log_stack;
 		else {
 			set_pv_devices(fid, vg, NULL);
 
diff -u -r ../src.orig/lib/format_text/text_label.c ./lib/format_text/text_label.c
--- ../src.orig/lib/format_text/text_label.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/format_text/text_label.c	2020-08-03 10:42:35.774486936 +0200
@@ -105,7 +105,7 @@
 	memcpy(pvhdr->pv_uuid, &lvmcache_device(info)->pvid, sizeof(struct id));
 	if (!id_write_format((const struct id *)pvhdr->pv_uuid, buffer,
 			     sizeof(buffer))) {
-		stack;
+		log_stack;
 		buffer[0] = '\0';
 	}
 
diff -u -r ../src.orig/lib/label/hints.c ./lib/label/hints.c
--- ../src.orig/lib/label/hints.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/label/hints.c	2020-08-03 10:42:35.777821932 +0200
@@ -224,7 +224,7 @@
 	if (!(fp = fopen(_newhints_file, "w")))
 		return_0;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -235,7 +235,7 @@
 	if (!(fp = fopen(_nohints_file, "w")))
 		return_0;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -246,7 +246,7 @@
 	if (!(fp = fopen(_hints_file, "w")))
 		return_0;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -324,7 +324,7 @@
 	}
 
 	if (close(fd))
-		stack;
+		log_stack;
 	return 0;
 }
 
@@ -345,7 +345,7 @@
 		log_warn("unlock_hints flock errno %d", errno);
 
 	if (close(_hints_fd))
-		stack;
+		log_stack;
 	_hints_fd = -1;
 }
 
@@ -551,7 +551,7 @@
 		 * we don't want to take an ex lock here.
 		 */
 		if (!_touch_newhints())
-			stack;
+			log_stack;
 	}
 
 	return ret;
@@ -795,7 +795,7 @@
 	}
 
 	if (fclose(fp))
-		stack;
+		log_stack;
 
 	if (!ret) {
 		free_hints(hints);
@@ -1006,7 +1006,7 @@
 
  out_flush:
 	if (fflush(fp))
-		stack;
+		log_stack;
 
 	log_debug("Wrote hint file with devs_hash %u count %u", hash, count);
 
@@ -1019,7 +1019,7 @@
 
  out_close:
 	if (fclose(fp))
-		stack;
+		log_stack;
 
  out_unlock:
 	/* get_hints() took ex lock before returning with newhints set */
@@ -1086,15 +1086,15 @@
 
 	/* limit potential delay blocking on hints lock next */
 	if (!_touch_nohints())
-		stack;
+		log_stack;
 
 	if (!_lock_hints(cmd, LOCK_EX, 0))
-		stack;
+		log_stack;
 
 	_unlink_nohints();
 
 	if (!_clear_hints(cmd))
-		stack;
+		log_stack;
 
 	/*
 	 * Creating a newhints file here is not necessary, since
@@ -1102,7 +1102,7 @@
 	 * is more efficient if it sees a newhints file first.
 	 */
 	if (!_touch_newhints())
-		stack;
+		log_stack;
 }
 
 /*
@@ -1122,15 +1122,15 @@
 
 	/* limit potential delay blocking on hints lock next */
 	if (!_touch_nohints())
-		stack;
+		log_stack;
 
 	if (!_lock_hints(cmd, LOCK_EX, 0))
-		stack;
+		log_stack;
 
 	_unlink_nohints();
 
 	if (!_clear_hints(cmd))
-		stack;
+		log_stack;
 }
 
 /*
@@ -1145,7 +1145,7 @@
 		return;
 
 	if (!_touch_newhints())
-		stack;
+		log_stack;
 }
 
 /*
diff -u -r ../src.orig/lib/label/label.c ./lib/label/label.c
--- ../src.orig/lib/label/label.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/label/label.c	2020-08-03 10:42:35.781156927 +0200
@@ -1636,7 +1636,7 @@
 	unsigned int bs;
 
 	if (!dev_get_direct_block_sizes(dev, &physical_block_size, &logical_block_size)) {
-		stack;
+		log_stack;
 		return; /* FIXME: error path ? */
 	}
 
diff -u -r ../src.orig/lib/locking/locking.c ./lib/locking/locking.c
--- ../src.orig/lib/locking/locking.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/locking/locking.c	2020-08-03 10:42:35.791161916 +0200
@@ -312,7 +312,7 @@
 			dm_list_uniterate(lvh, lvs, &lvl->list) {
 				lvl = dm_list_item(lvh, struct lv_list);
 				if (!deactivate_lv(cmd, lvl->lv))
-					stack;
+					log_stack;
 			}
 			return 0;
 		}
diff -u -r ../src.orig/lib/locking/locking.h ./lib/locking/locking.h
--- ../src.orig/lib/locking/locking.h	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/locking/locking.h	2020-08-03 10:42:35.791161916 +0200
@@ -57,9 +57,9 @@
 #define unlock_vg(cmd, vg, vol)	\
 	do { \
 		if (is_real_vg(vol) && !sync_local_dev_names(cmd)) \
-			stack; \
+			log_stack; \
 		if (!lock_vol(cmd, vol, LCK_VG_UNLOCK, NULL)) \
-			stack;	\
+			log_stack;	\
 	} while (0)
 #define unlock_and_release_vg(cmd, vg, vol) \
 	do { \
diff -u -r ../src.orig/lib/locking/lvmlockd.c ./lib/locking/lvmlockd.c
--- ../src.orig/lib/locking/lvmlockd.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/locking/lvmlockd.c	2020-08-03 10:42:35.794496912 +0200
@@ -788,7 +788,7 @@
 		_deactivate_sanlock_lv(cmd, vg);
 		_remove_sanlock_lv(cmd, vg);
 		if (!vg_write(vg) || !vg_commit(vg))
-			stack;
+			log_stack;
 	}
 
 	daemon_reply_destroy(reply);
diff -u -r ../src.orig/lib/log/log.h ./lib/log/log.h
--- ../src.orig/lib/log/log.h	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/log/log.h	2020-08-03 10:42:58.946039611 +0200
@@ -28,7 +28,7 @@
  * In addition, messages will be logged to file or syslog if they
  * are more serious than the log level specified with the log/debug_level
  * parameter in the configuration file.  These messages get the file
- * and line number prepended.  'stack' (without arguments) can be used 
+ * and line number prepended.  'log_stack' (without arguments) can be used 
  * to log this information at debug level.
  *
  * log_sys_error and log_sys_very_verbose are for errors from system calls
@@ -103,7 +103,7 @@
 #define log_err_once(x...) LOG_LINE_WITH_ERRNO(_LOG_ERR | _LOG_ONCE, EUNCLASSIFIED, x)
 #define log_fatal(x...) LOG_LINE_WITH_ERRNO(_LOG_FATAL, EUNCLASSIFIED, x)
 
-#define stack log_debug("<backtrace>")	/* Backtrace on error */
+#define log_stack log_debug("<backtrace>")	/* Backtrace on error */
 #define log_very_verbose(args...) log_info(args)
 #define log_verbose(args...) log_notice(args)
 #define log_print(args...) LOG_LINE(_LOG_WARN, args)
@@ -123,12 +123,12 @@
 #define log_sys_debug(x, y) \
 		log_debug("%s: %s failed: %s", y, x, strerror(errno))
 
-#define return_0	do { stack; return 0; } while (0)
-#define return_NULL	do { stack; return NULL; } while (0)
+#define return_0	do { log_stack; return 0; } while (0)
+#define return_NULL	do { log_stack; return NULL; } while (0)
 #define return_EINVALID_CMD_LINE \
-			do { stack; return EINVALID_CMD_LINE; } while (0)
-#define return_ECMD_FAILED do { stack; return ECMD_FAILED; } while (0)
-#define goto_out	do { stack; goto out; } while (0)
-#define goto_bad	do { stack; goto bad; } while (0)
+			do { log_stack; return EINVALID_CMD_LINE; } while (0)
+#define return_ECMD_FAILED do { log_stack; return ECMD_FAILED; } while (0)
+#define goto_out	do { log_stack; goto out; } while (0)
+#define goto_bad	do { log_stack; goto bad; } while (0)
 
 #endif
Only in ./lib/log: log.h~
diff -u -r ../src.orig/lib/lvmpolld/lvmpolld-client.c ./lib/lvmpolld/lvmpolld-client.c
--- ../src.orig/lib/lvmpolld/lvmpolld-client.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/lvmpolld/lvmpolld-client.c	2020-08-03 10:42:35.804501900 +0200
@@ -180,7 +180,7 @@
 		ret.error = 0;
 	} else {
 		_process_error_response(rep);
-		stack;
+		log_stack;
 	}
 
 out_rep:
@@ -259,7 +259,7 @@
 		r = 1;
 	else {
 		_process_error_response(rep);
-		stack;
+		log_stack;
 	}
 
 out_rep:
diff -u -r ../src.orig/lib/metadata/cache_manip.c ./lib/metadata/cache_manip.c
--- ../src.orig/lib/metadata/cache_manip.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/cache_manip.c	2020-08-03 10:42:35.811171892 +0200
@@ -496,7 +496,7 @@
 				cache_seg->cleaner_policy = 0;
 				/* Restore normal table */
 				if (!lv_update_and_reload_origin(cache_lv))
-					stack;
+					log_stack;
 			}
 			return 0;
 		}
diff -u -r ../src.orig/lib/metadata/lv.c ./lib/metadata/lv.c
--- ../src.orig/lib/metadata/lv.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/lv.c	2020-08-03 10:42:35.811171892 +0200
@@ -277,7 +277,7 @@
 		goto_bad;
 
 	if (!(ret = lvseg_kernel_discards_dup_with_info_and_seg_status(mem, &status)))
-		stack;
+		log_stack;
 bad:
 	dm_pool_destroy(status.seg_status.mem);
 
@@ -650,7 +650,7 @@
 		 (lv_is_cache_pool_data(lv) || lv_is_cache_pool_metadata(lv)) ||
 		 (lv_is_thin_pool_data(lv) || lv_is_thin_pool_metadata(lv))) {
 		if (!(seg = get_only_segment_using_this_lv(lv)))
-			stack;
+			log_stack;
 		else
 			parent_lv = seg->lv;
 	}
diff -u -r ../src.orig/lib/metadata/lv_manip.c ./lib/metadata/lv_manip.c
--- ../src.orig/lib/metadata/lv_manip.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/lv_manip.c	2020-08-03 10:42:35.817841885 +0200
@@ -2108,10 +2108,10 @@
 					       (top_level_area_index != -1) ? top_level_area_index : (int) (s * stripes_per_mimage),
 					       only_single_area_segments, fn,
 					       data)))
-				stack;
+				log_stack;
 		} else if (seg_type(seg, s) == AREA_PV)
 			if (!(r = fn(cmd, seg_pvseg(seg, s), top_level_area_index != -1 ? (uint32_t) top_level_area_index + s : s, data)))
-				stack;
+				log_stack;
 		if (r != 1)
 			return r;
 	}
@@ -2121,7 +2121,7 @@
 		if (!(r = _for_each_pv(cmd, seg->log_lv, 0, seg->log_lv->le_count, NULL,
 				       NULL, 0, 0, 0, only_single_area_segments,
 				       fn, data)))
-			stack;
+			log_stack;
 		if (r != 1)
 			return r;
 	}
@@ -2134,7 +2134,7 @@
 			if (seg_metalv(seg, s))
 				if (!(r = _for_each_pv(cmd, seg_metalv(seg, s), 0, seg_metalv(seg, s)->le_count, NULL,
 						       NULL, 0, 0, 0, 0, fn, data)))
-					stack;
+					log_stack;
 			if (r != 1)
 				return r;
 		}
@@ -2552,7 +2552,7 @@
 	if (!(r = _for_each_pv(ah->cmd, prev_lvseg->lv, le, len, NULL, NULL,
 			       0, 0, -1, 1,
 			       _is_condition, &pvmatch)))
-		stack;
+		log_stack;
 
 	if (r != 2)
 		return 0;
@@ -2581,7 +2581,7 @@
 			       prev_lvseg->le + prev_lvseg->len - 1, 1, NULL, NULL,
 			       0, 0, -1, 1,
 			       _is_condition, &pvmatch)))
-		stack;
+		log_stack;
 
 	if (r != 2)
 		return 0;
@@ -3247,7 +3247,7 @@
 		return_0;
 
 	if (!_log_parallel_areas(ah->mem, ah->parallel_areas, ah->cling_tag_list_cn))
-		stack;
+		log_stack;
 
 	alloc_state.areas_size = dm_list_size(pvms);
 	if (alloc_state.areas_size &&
@@ -4315,11 +4315,11 @@
 
 	if (segtype_is_pool(segtype)) {
 		if (!(r = create_pool(lv, segtype, ah, stripes, stripe_size)))
-			stack;
+			log_stack;
 	} else if (!segtype_is_mirror(segtype) && !segtype_is_raid(segtype)) {
 		if (!(r = lv_add_segment(ah, 0, ah->area_count, lv, segtype,
 					 stripe_size, 0u, 0)))
-			stack;
+			log_stack;
 	} else {
 		/*
 		 * For RAID, all the devices are AREA_LV.
@@ -5187,11 +5187,11 @@
 
 	/* Top-level LV first */
 	if (!_add_pes(lv, &pe_total))
-		stack;
+		log_stack;
 
 	/* Any sub-LVs */
 	if (!for_each_sub_lv(lv, _add_pes, &pe_total))
-		stack;
+		log_stack;
 
 	return pe_total;
 }
@@ -5869,7 +5869,7 @@
 
 	if (lv_is_cow_covering_origin(lv))
 		if (!monitor_dev_for_events(cmd, lv, 0, 0))
-			stack;
+			log_stack;
 
 	if (lv_is_thin_pool(lock_lv)) {
 		/* Update lvm pool metadata (drop messages). */
@@ -6060,7 +6060,7 @@
 	int historical;
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (strstr(name, "%d") &&
 	    !(name = generate_lv_name(vg, name, dname, sizeof(dname)))) {
@@ -6604,7 +6604,7 @@
 			goto no_remove;
 
 		if (!deactivate_lv(cmd, lv)) {
-			stack;
+			log_stack;
 			goto no_remove;
 		}
 		log_verbose("Removing origin logical volume %s with %u snapshots(s).",
@@ -6712,7 +6712,7 @@
 			  display_lvname(lock_lv));
 		vg_revert(vg);
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implict vg_revert() */
+		log_stack; /* !vg_commit() has implict vg_revert() */
 	else
 		do_backup = 1;
 
@@ -6908,7 +6908,7 @@
 		}
 	}
 	if (lv_changed && !lv_merge_segments(lv))
-		stack;
+		log_stack;
 
 	return 1;
 }
@@ -7479,7 +7479,7 @@
 		if (!wipe_known_signatures(lv->vg->cmd, dev, name, 0,
 					   TYPE_DM_SNAPSHOT_COW,
 					   wp.yes, wp.force, NULL))
-			stack;
+			log_stack;
 	}
 
 	if (wp.do_zero) {
@@ -7494,10 +7494,10 @@
 
 		if (!wp.zero_value) {
 			if (!dev_write_zeros(dev, UINT64_C(0), (size_t) zero_sectors << SECTOR_SHIFT))
-				stack;
+				log_stack;
 		} else {
 			if (!dev_set_bytes(dev, UINT64_C(0), (size_t) zero_sectors << SECTOR_SHIFT, (uint8_t)wp.zero_value))
-				stack;
+				log_stack;
 		}
 	}
 
@@ -8117,7 +8117,7 @@
 				      lp->cache_mode,
 				      lp->policy_name,
 				      lp->policy_settings)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 	} else if (lv_is_raid(lv) && !seg_is_any_raid0(first_seg(lv))) {
@@ -8128,7 +8128,7 @@
 		first_seg(lv)->zero_new_blocks = lp->zero_new_blocks;
 		first_seg(lv)->discards = lp->discards;
 		if (!recalculate_pool_chunk_size_with_dev_hints(lv, lp->thin_chunk_size_calc_policy)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 		if (lp->error_when_full)
@@ -8167,7 +8167,7 @@
 		if (!add_mirror_log(cmd, lv, lp->log_count,
 				    first_seg(lv)->region_size,
 				    lp->pvh, lp->alloc)) {
-			stack;
+			log_stack;
 			goto revert_new_lv;
 		}
 	}
@@ -8242,7 +8242,7 @@
 			}
 			/* At this point remove pool messages, snapshot is active */
 			if (!update_pool_lv(pool_lv, 0)) {
-				stack;
+				log_stack;
 				goto revert_new_lv;
 			}
 		}
@@ -8265,7 +8265,7 @@
 			}
 			/* Keep thin pool active until thin volume is activated */
 			if (!update_pool_lv(pool_lv, 1)) {
-				stack;
+				log_stack;
 				goto revert_new_lv;
 			}
 		}
@@ -8312,7 +8312,7 @@
 
 	if (seg_is_vdo_pool(lp)) {
 		if (!convert_vdo_pool_lv(lv, &lp->vdo_params, &lp->virtual_extents)) {
-			stack;
+			log_stack;
 			goto deactivate_and_revert_new_lv;
 		}
 	} else if (seg_is_cache(lp) || (origin_lv && lv_is_cache_pool(lv))) {
@@ -8328,7 +8328,7 @@
 		} else {
 			if (!(tmp_lv = lv_cache_create(pool_lv, lv))) {
 				/* 'lv' still keeps created new LV */
-				stack;
+				log_stack;
 				goto deactivate_and_revert_new_lv;
 			}
 		}
diff -u -r ../src.orig/lib/metadata/metadata.c ./lib/metadata/metadata.c
--- ../src.orig/lib/metadata/metadata.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/metadata.c	2020-08-03 10:42:35.824511877 +0200
@@ -372,7 +372,7 @@
 	if (find_pv_in_vg(vg, pv_name) ||
 	    find_pv_in_vg_by_uuid(vg, &pv->id)) {
 		if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-			stack;
+			log_stack;
 			uuid[0] = '\0';
 		}
 		log_error("Physical volume '%s (%s)' already in the VG.",
@@ -659,7 +659,7 @@
 	set_vg_notify(vg->cmd);
 
 	if (!backup_remove(vg->cmd, vg->name))
-		stack;
+		log_stack;
 
 	if (ret)
 		log_print_unless_silent("Volume group \"%s\" successfully removed", vg->name);
@@ -2016,7 +2016,7 @@
 
 	dm_list_iterate_items(lvl, &vg->lvs)
 		if (!_lv_postorder_visit(lvl->lv, fn, data)) {
-			stack;
+			log_stack;
 			r = 0;
 		}
 
@@ -2314,7 +2314,7 @@
 					  sizeof(pvl->pv->id))) {
 			if (!id_write_format(&pvl->pv->id, uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate PV id "
 				  "%s detected for %s in %s.",
 				  uuid, pv_dev_name(pvl->pv),
@@ -2381,10 +2381,10 @@
 		if (!id_equal(&lvl->lv->lvid.id[0], &lvl->lv->vg->id)) {
 			if (!id_write_format(&lvl->lv->lvid.id[0], uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			if (!id_write_format(&lvl->lv->vg->id, uuid2,
 					     sizeof(uuid2)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "LV %s has VG UUID %s but its VG %s has UUID %s",
 				  lvl->lv->name, uuid, lvl->lv->vg->name, uuid2);
 			r = 0;
@@ -2494,7 +2494,7 @@
 					  sizeof(lvl->lv->lvid.id[1]))) {
 			if (!id_write_format(&lvl->lv->lvid.id[1], uuid,
 					     sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate LV id "
 				  "%s detected for %s in %s.",
 				  uuid, lvl->lv->name, vg->name);
@@ -2522,7 +2522,7 @@
 	}
 
 	if (!_lv_postorder_vg(vg, _lv_validate_references_single, &vhash)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -2561,7 +2561,7 @@
 	}
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (!(vhash.lv_lock_args = dm_hash_create(lv_count))) {
 		log_error("Failed to allocate lv_lock_args hash");
@@ -2718,9 +2718,9 @@
 
 		if (!id_equal(&hlv->lvid.id[0], &hlv->vg->id)) {
 			if (!id_write_format(&hlv->lvid.id[0], uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			if (!id_write_format(&hlv->vg->id, uuid2, sizeof(uuid2)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Historical LV %s has VG UUID %s but its VG %s has UUID %s",
 				  hlv->name, uuid, hlv->vg->name, uuid2);
 			r = 0;
@@ -2729,7 +2729,7 @@
 
 		if (dm_hash_lookup_binary(vhash.historical_lvid, &hlv->lvid.id[1], sizeof(hlv->lvid.id[1]))) {
 			if (!id_write_format(&hlv->lvid.id[1], uuid,sizeof(uuid)))
-				stack;
+				log_stack;
 			log_error(INTERNAL_ERROR "Duplicate historical LV id %s detected for %s in %s",
 				  uuid, hlv->name, vg->name);
                         r = 0;
@@ -3060,7 +3060,7 @@
 				log_warn("WARNING: Failed to write an MDA of VG %s.", vg->name);
 				mda->status |= MDA_FAILED;
 			} else {
-				stack;
+				log_stack;
 				revert = 1;
 				break;
 			}
@@ -3078,7 +3078,7 @@
 
 			if (mda->ops->vg_revert &&
 			    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-				stack;
+				log_stack;
 			}
 		}
 		return 0;
@@ -3090,14 +3090,14 @@
 			continue;
 		if (mda->ops->vg_precommit &&
 		    !mda->ops->vg_precommit(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 			/* Revert */
 			dm_list_iterate_items(mda, &vg->fid->metadata_areas_in_use) {
 				if (mda->status & MDA_FAILED)
 					continue;
 				if (mda->ops->vg_revert &&
 				    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-					stack;
+					log_stack;
 				}
 			}
 			return 0;
@@ -3136,7 +3136,7 @@
 		failed = 0;
 		if (mda->ops->vg_commit &&
 		    !mda->ops->vg_commit(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 			failed = 1;
 		} else
 			good++;
@@ -3197,7 +3197,7 @@
 	dm_list_iterate_items(mda, &vg->fid->metadata_areas_in_use) {
 		if (mda->ops->vg_revert &&
 		    !mda->ops->vg_revert(vg->fid, vg, mda)) {
-			stack;
+			log_stack;
 		}
 	}
 }
@@ -3217,7 +3217,7 @@
 	uint32_t ext_flags;
 
 	if (!(pv = _pv_read(b->cmd, b->fmt, b->vg, info))) {
-		stack;
+		log_stack;
 		return 1;
 	}
 
@@ -3244,7 +3244,7 @@
 
 	/*
 	if (!_check_or_repair_orphan_pv_ext(pv, info, baton)) {
-		stack;
+		log_stack;
 		return 0;
 	}
 	*/
diff -u -r ../src.orig/lib/metadata/mirror.c ./lib/metadata/mirror.c
--- ../src.orig/lib/metadata/mirror.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/mirror.c	2020-08-03 10:42:35.827846872 +0200
@@ -1795,7 +1795,7 @@
 					  (region_size > lv->vg->extent_size) ?
 					  lv->vg->extent_size : region_size,
 					  alloc, mirror_in_sync()))) {
-		stack;
+		log_stack;
 		goto out_remove_images;
 	}
 
@@ -1807,7 +1807,7 @@
 		goto out_remove_log;
 
 	if (log_count && !attach_mirror_log(first_seg(lv), log_lv))
-		stack;
+		log_stack;
 
 	alloc_destroy(ah);
 	return 1;
diff -u -r ../src.orig/lib/metadata/raid_manip.c ./lib/metadata/raid_manip.c
--- ../src.orig/lib/metadata/raid_manip.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/raid_manip.c	2020-08-03 10:42:35.844521852 +0200
@@ -662,7 +662,7 @@
 			  display_lvname(lock_lv));
 		vg_revert(vg);
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implicit vg_revert() */
+		log_stack; /* !vg_commit() has implicit vg_revert() */
 
 	if (r && lv_list) {
 		dm_list_iterate_items(lvl, lv_list) {
@@ -2195,7 +2195,7 @@
 			  display_lvname(lv));
 		vg_revert(lv->vg);
 	} else if (!(r = vg_commit(vg)))
-		stack; /* !vg_commit() has implicit vg_revert() */
+		log_stack; /* !vg_commit() has implicit vg_revert() */
 
 	if (r && do_backup)
 		backup(vg);
@@ -4793,7 +4793,7 @@
 			  (new_stripes == 1)) ? SEG_TYPE_NAME_LINEAR : new_segtype->name);
 
 	if (!_log_possible_conversion_types(lv, new_segtype))
-		stack;
+		log_stack;
 
 	return 0;
 }
@@ -4806,7 +4806,7 @@
 		   (new_stripes == 1)) ? SEG_TYPE_NAME_LINEAR : new_segtype->name);
 
 	if (!_log_possible_conversion_types(lv, new_segtype))
-		stack;
+		log_stack;
 
 	return 0;
 }
diff -u -r ../src.orig/lib/metadata/thin_manip.c ./lib/metadata/thin_manip.c
--- ../src.orig/lib/metadata/thin_manip.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/thin_manip.c	2020-08-03 10:42:35.851191845 +0200
@@ -516,7 +516,7 @@
 			activate = 0; /* Was already active */
 
 		if (!(ret = _check_pool_create(lv)))
-			stack; /* Safety guard, needs local presence of thin-pool target */
+			log_stack; /* Safety guard, needs local presence of thin-pool target */
 		else {
 			if (!(ret = suspend_lv_origin(lv->vg->cmd, lv)))
 				/* Send messages */
diff -u -r ../src.orig/lib/metadata/vg.c ./lib/metadata/vg.c
--- ../src.orig/lib/metadata/vg.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/metadata/vg.c	2020-08-03 10:42:35.854526842 +0200
@@ -109,7 +109,7 @@
 	struct lv_list *lvl;
 
 	if (vg_max_lv_reached(vg))
-		stack;
+		log_stack;
 
 	if (!(lvl = dm_pool_zalloc(vg->vgmem, sizeof(*lvl))))
 		return_0;
diff -u -r ../src.orig/lib/mirror/mirrored.c ./lib/mirror/mirrored.c
--- ../src.orig/lib/mirror/mirrored.c	2020-08-03 10:42:24.462180269 +0200
+++ ./lib/mirror/mirrored.c	2020-08-03 10:42:35.861196833 +0200
@@ -380,7 +380,7 @@
 		return_0;
 
 	if ((r = _add_log(mem, seg, laopts, node, area_count, region_size)) <= 0) {
-		stack;
+		log_stack;
 		return r;
 	}
 
diff -u -r ../src.orig/lib/misc/lvm-exec.c ./lib/misc/lvm-exec.c
--- ../src.orig/lib/misc/lvm-exec.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/misc/lvm-exec.c	2020-08-03 10:42:35.874536818 +0200
@@ -171,7 +171,7 @@
 	if (pdata->pid == 0) {
 		/* Child -> writer, convert pipe[0] to STDOUT */
 		if (!_reopen_fd_to_null(STDIN_FILENO))
-			stack;
+			log_stack;
 		else if (close(pipefd[0 /*read*/]))
 			log_sys_error("close", "pipe[0]");
 		else if (close(STDOUT_FILENO))
diff -u -r ../src.orig/lib/misc/lvm-file.c ./lib/misc/lvm-file.c
--- ../src.orig/lib/misc/lvm-file.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/misc/lvm-file.c	2020-08-03 10:42:35.877871813 +0200
@@ -233,7 +233,7 @@
 		if (warn_if_read_only || (errno != EROFS && errno != EACCES))
 			log_sys_error("open", file);
 		else
-			stack;
+			log_stack;
 
 		return -1;
 	}
diff -u -r ../src.orig/lib/misc/lvm-flock.c ./lib/misc/lvm-flock.c
--- ../src.orig/lib/misc/lvm-flock.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/misc/lvm-flock.c	2020-08-03 10:42:35.881206810 +0200
@@ -241,7 +241,7 @@
 	else {
 		free(ll->res);
 		free(ll);
-		stack;
+		log_stack;
 	}
 
 	return r;
diff -u -r ../src.orig/lib/misc/lvm-wrappers.c ./lib/misc/lvm-wrappers.c
--- ../src.orig/lib/misc/lvm-wrappers.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/misc/lvm-wrappers.c	2020-08-03 10:42:35.901216785 +0200
@@ -113,12 +113,12 @@
 	if (read(fd, buf, len) != (ssize_t) len) {
 		log_sys_error("read", "read_urandom: /dev/urandom");
 		if (close(fd))
-			stack;
+			log_stack;
 		return 0;
 	}
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	return 1;
 }
diff -u -r ../src.orig/lib/mm/memlock.c ./lib/mm/memlock.c
--- ../src.orig/lib/mm/memlock.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/mm/memlock.c	2020-08-03 10:42:35.911221775 +0200
@@ -79,7 +79,7 @@
 
 #else				/* DEVMAPPER_SUPPORT */
 
-static size_t _size_stack;
+static size_t _size_log_stack;
 static size_t _size_malloc_tmp;
 static size_t _size_malloc = 2000000;
 
@@ -538,11 +538,11 @@
 		}
 
 		if (!_disable_mmap())
-			stack;
+			log_stack;
 	}
 
 	if (!_memlock_maps(cmd, LVM_MLOCK, &_mstats))
-		stack;
+		log_stack;
 }
 
 static void _unlock_mem(struct cmd_context *cmd)
@@ -552,7 +552,7 @@
 	log_very_verbose("Unlocking memory");
 
 	if (!_memlock_maps(cmd, LVM_MUNLOCK, &unlock_mstats))
-		stack;
+		log_stack;
 
 	if (!_use_mlockall) {
 		_restore_mmap();
diff -u -r ../src.orig/lib/raid/raid.c ./lib/raid/raid.c
--- ../src.orig/lib/raid/raid.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/raid/raid.c	2020-08-03 10:42:35.921226763 +0200
@@ -671,7 +671,7 @@
 		if ((segtype = _init_raid_segtype(cmd, &_raid_types[i], dso, monitored)) &&
 		    !lvm_register_segtype(seglib, segtype)) {
 			/* segtype is already destroyed */
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
diff -u -r ../src.orig/lib/report/properties.c ./lib/report/properties.c
--- ../src.orig/lib/report/properties.c	2020-08-03 10:42:24.465515266 +0200
+++ ./lib/report/properties.c	2020-08-03 10:42:35.927896755 +0200
@@ -111,7 +111,7 @@
 
 	if (lv_is_cache(lv) || lv_is_used_cache_pool(lv)) {
 		if (!lv_cache_status(lv, &status)) {
-			stack;
+			log_stack;
 			return DM_PERCENT_INVALID;
 		}
 		percent = status->data_usage;
@@ -132,7 +132,7 @@
 
 	if (lv_is_cache(lv) || lv_is_used_cache_pool(lv)) {
 		if (!lv_cache_status(lv, &status)) {
-			stack;
+			log_stack;
 			return DM_PERCENT_INVALID;
 		}
 		percent = status->metadata_usage;
diff -u -r ../src.orig/libdm/dm-tools/dmsetup.c ./libdm/dm-tools/dmsetup.c
--- ../src.orig/libdm/dm-tools/dmsetup.c	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/dm-tools/dmsetup.c	2020-08-03 10:42:36.041286621 +0200
@@ -656,7 +656,7 @@
 	/* Final interval? */
 	if (_count == 2) {
 		if (close(_timer_fd))
-			stack;
+			log_stack;
 		/* Tell _update_interval_times() to shut down. */
 		_timer_fd = TIMER_STOPPED;
 	}
@@ -727,7 +727,7 @@
 		else if (errno == EINVAL)
 			log_error("Report interval too short.");
 		else
-			stack; /* other reason */
+			log_stack; /* other reason */
 		return 0;
 	}
 
@@ -3360,7 +3360,7 @@
 	if (private) {
 		if (!dm_device_get_name(info->major, info->minor,
 					1, buf, PATH_MAX)) {
-			stack;
+			log_stack;
 			goto out_abandon;
 		}
 	}
@@ -7239,9 +7239,9 @@
 		dm_log_init_verbose(_switches[VERBOSE_ARG] - 1);
 		if (_switches[VERBOSE_ARG] > 2) {
 			if (!(_initial_timestamp = dm_timestamp_alloc()))
-				stack;
+				log_stack;
 			else if (!dm_timestamp_get(_initial_timestamp))
-				stack;
+				log_stack;
 			else
 				log_debug("Timestamp:       0.000000000 seconds");
 		}
diff -u -r ../src.orig/libdm/ioctl/libdm-iface.c ./libdm/ioctl/libdm-iface.c
--- ../src.orig/libdm/ioctl/libdm-iface.c	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/ioctl/libdm-iface.c	2020-08-03 10:42:36.047956614 +0200
@@ -558,7 +558,7 @@
 
 	r = dm_task_run(task);
 	if (!dm_task_get_driver_version(task, version, size))
-		stack;
+		log_stack;
 	dm_task_destroy(task);
 	_log_suppress = 0;
 
@@ -1336,12 +1336,12 @@
 			continue;
 		if (!dm_task_set_name(dmt, dirent->d_name)) {
 			r = 0;
-			stack;
+			log_stack;
 			continue; /* try next name */
 		}
 		if (!dm_task_run(dmt)) {
 			r = 0;
-			stack;  /* keep going */
+			log_stack;  /* keep going */
 		}
 	}
 
@@ -1467,14 +1467,14 @@
 
 	/* Next load the table */
 	if (!(task = dm_task_create(DM_DEVICE_RELOAD))) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
 
 	/* Copy across relevant fields */
 	if (dmt->dev_name && !dm_task_set_name(task, dmt->dev_name)) {
-		stack;
+		log_stack;
 		dm_task_destroy(task);
 		_udev_complete(dmt);
 		goto revert;
@@ -1494,7 +1494,7 @@
 	dm_task_destroy(task);
 
 	if (!r) {
-		stack;
+		log_stack;
 		_udev_complete(dmt);
 		goto revert;
 	}
@@ -1528,7 +1528,7 @@
 		if (!dm_task_set_cookie(dmt, &cookie,
 					(dmt->event_nr & DM_UDEV_FLAGS_MASK) >>
 					DM_UDEV_FLAGS_SHIFT))
-			stack; /* keep going */
+			log_stack; /* keep going */
 	}
 
 	if (!dm_task_run(dmt))
@@ -1901,7 +1901,7 @@
 
 	if (dmt->record_timestamp)
 		if (!dm_timestamp_get(_dm_ioctl_timestamp))
-			stack;
+			log_stack;
 
 	if (r < 0 && dmt->expected_errno != errno) {
 		dmt->ioctl_errno = errno;
diff -u -r ../src.orig/libdm/libdm-common.c ./libdm/libdm-common.c
--- ../src.orig/libdm/libdm-common.c	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/libdm-common.c	2020-08-03 10:42:36.054626606 +0200
@@ -1809,7 +1809,7 @@
 	while (!feof(minfo) && fgets(buffer, sizeof(buffer), minfo))
 		if (!_mountinfo_parse_line(buffer, &maj, &min, target) ||
 		    !read_fn(buffer, maj, min, target, cb_data)) {
-			stack;
+			log_stack;
 			r = 0;
 			break;
 		}
@@ -2055,7 +2055,7 @@
 		if (_sysfs_get_dm_name(major, minor, buf, buf_size))
 			return 1;
 		else
-			stack;
+			log_stack;
 	}
 
 	/*
@@ -2149,7 +2149,7 @@
 	if ((major == data->maj) && (minor == data->min)) {
 		if (!dm_device_get_name(major, minor, 1, kernel_dev_name,
 					sizeof(kernel_dev_name))) {
-			stack;
+			log_stack;
 			*kernel_dev_name = '\0';
 		}
 		log_verbose("Device %s (%u:%u) appears to be mounted on %s.",
@@ -2169,7 +2169,7 @@
 	};
 
 	if (!dm_mountinfo_read(_device_has_mounted_fs, &data))
-		stack;
+		log_stack;
 
 	if (data.mounted)
 		return 1;
@@ -2572,7 +2572,7 @@
 			     gen_cookie, gen_semid, val);
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*semid = gen_semid;
 	*cookie = gen_cookie;
@@ -2581,7 +2581,7 @@
 
 bad:
 	if (close(fd))
-		stack;
+		log_stack;
 
 	*cookie = 0;
 
diff -u -r ../src.orig/libdm/libdm-deptree.c ./libdm/libdm-deptree.c
--- ../src.orig/libdm/libdm-deptree.c	2020-08-03 10:42:24.468850261 +0200
+++ ./libdm/libdm-deptree.c	2020-08-03 10:42:36.104651547 +0200
@@ -613,7 +613,7 @@
 			"%s (" FMTu32 ":" FMTu32 ")",
 			dnode->name ? dnode->name : "",
 			dnode->info.major, dnode->info.minor) < 0) {
-		stack;
+		log_stack;
 		return dnode->name;
 	}
 
@@ -738,7 +738,7 @@
 
 	dm_list_iterate_items(dlink, list) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -957,7 +957,7 @@
 	/* Iterate through parents of this node */
 	dm_list_iterate_items(dlink, &node->used_by) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1220,7 +1220,7 @@
 	/* Can't recurse if not a mapped device or there are no dependencies */
 	if (!node->info.exists || !deps || !deps->count) {
 		if (!_add_to_bottomlevel(node)) {
-			stack;
+			log_stack;
 			node = NULL;
 		}
 		goto out;
@@ -1334,7 +1334,7 @@
 		dec_suspended();
 
 	if (!(r = dm_task_get_info(dmt, newinfo)))
-		stack;
+		log_stack;
 
 out:
 	dm_task_destroy(dmt);
@@ -1600,17 +1600,17 @@
 
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1640,7 +1640,7 @@
 
 			/* Check toplevel node for holders/mounted fs */
 			if (!_check_device_not_in_use(name, &info)) {
-				stack;
+				log_stack;
 				r = 0;
 				continue;
 			}
@@ -1680,7 +1680,7 @@
 		if (child->callback &&
 		    !child->callback(child, DM_NODE_CALLBACK_DEACTIVATED,
 				     child->callback_data))
-			stack;
+			log_stack;
 			/* FIXME Deactivation must currently ignore failure
 			 * here so that lvremove can continue: we need an
 			 * alternative way to handle this state without 
@@ -1717,17 +1717,17 @@
 	/* Suspend nodes at this level of the tree */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1748,7 +1748,7 @@
 		/* If child has some real messages send them */
 		if ((child->props.send_messages > 1) && r) {
 			if (!(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 			else {
 				log_debug_activation("Sent messages to thin-pool %s and "
 						     "skipping suspend of its children.",
@@ -1779,7 +1779,7 @@
 			continue;
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1827,7 +1827,7 @@
 			continue;
 
 		if (!(sibling_name = dm_tree_node_get_name(sibling))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1856,7 +1856,7 @@
 	/* Activate children first */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1877,7 +1877,7 @@
 				continue;
 
 			if (!(uuid = dm_tree_node_get_uuid(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1885,7 +1885,7 @@
 				continue;
 
 			if (!(name = dm_tree_node_get_name(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1932,7 +1932,7 @@
 	 */
 	if (r && (dnode->props.send_messages > 1) &&
 	    !(r = _node_send_messages(dnode, uuid_prefix, uuid_prefix_len, 1)))
-		stack;
+		log_stack;
 
 	return r;
 }
@@ -2035,7 +2035,7 @@
 do {\
 	int w;\
 	if ((w = dm_snprintf(params + p, paramsize - (size_t) p, str)) < 0) {\
-		stack; /* Out of space */\
+		log_stack; /* Out of space */\
 		return -1;\
 	}\
 	p += w;\
@@ -2628,7 +2628,7 @@
 	case SEG_LINEAR:
 	case SEG_STRIPED:
 		if ((r = _emit_areas_line(dmt, seg, params, paramsize, &pos)) <= 0) {
-			stack;
+			log_stack;
 			return r;
 		}
 		if (!params[0]) {
@@ -2676,7 +2676,7 @@
 		dm_free(params);
 
 		if (!ret)
-			stack;
+			log_stack;
 
 		if (ret >= 0)
 			return ret;
@@ -2880,9 +2880,9 @@
 			/* When creating new node also check transaction_id. */
 			if (child->props.send_messages &&
 			    !_node_send_messages(child, uuid_prefix, uuid_prefix_len, 0)) {
-				stack;
+				log_stack;
 				if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-					stack;
+					log_stack;
 				dm_tree_set_cookie(dnode, 0);
 				(void) _dm_tree_revert_activated(dnode);
 				r = 0;
@@ -2902,7 +2902,7 @@
 	if (update_devs_flag ||
 	    (r && !dnode->info.exists && dnode->callback)) {
 		if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-			stack;
+			log_stack;
 		dm_tree_set_cookie(dnode, 0);
 
 		if (r && !dnode->info.exists && dnode->callback &&
diff -u -r ../src.orig/libdm/libdm-deptree.c.orig ./libdm/libdm-deptree.c.orig
--- ../src.orig/libdm/libdm-deptree.c.orig	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/libdm-deptree.c.orig	2020-08-03 10:42:36.101316549 +0200
@@ -613,7 +613,7 @@
 			"%s (" FMTu32 ":" FMTu32 ")",
 			dnode->name ? dnode->name : "",
 			dnode->info.major, dnode->info.minor) < 0) {
-		stack;
+		log_stack;
 		return dnode->name;
 	}
 
@@ -738,7 +738,7 @@
 
 	dm_list_iterate_items(dlink, list) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -957,7 +957,7 @@
 	/* Iterate through parents of this node */
 	dm_list_iterate_items(dlink, &node->used_by) {
 		if (!(uuid = dm_tree_node_get_uuid(dlink->node))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1220,7 +1220,7 @@
 	/* Can't recurse if not a mapped device or there are no dependencies */
 	if (!node->info.exists || !deps || !deps->count) {
 		if (!_add_to_bottomlevel(node)) {
-			stack;
+			log_stack;
 			node = NULL;
 		}
 		goto out;
@@ -1334,7 +1334,7 @@
 		dec_suspended();
 
 	if (!(r = dm_task_get_info(dmt, newinfo)))
-		stack;
+		log_stack;
 
 out:
 	dm_task_destroy(dmt);
@@ -1600,17 +1600,17 @@
 
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1640,7 +1640,7 @@
 
 			/* Check toplevel node for holders/mounted fs */
 			if (!_check_device_not_in_use(name, &info)) {
-				stack;
+				log_stack;
 				r = 0;
 				continue;
 			}
@@ -1680,7 +1680,7 @@
 		if (child->callback &&
 		    !child->callback(child, DM_NODE_CALLBACK_DEACTIVATED,
 				     child->callback_data))
-			stack;
+			log_stack;
 			/* FIXME Deactivation must currently ignore failure
 			 * here so that lvremove can continue: we need an
 			 * alternative way to handle this state without 
@@ -1717,17 +1717,17 @@
 	/* Suspend nodes at this level of the tree */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(dinfo = dm_tree_node_get_info(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(name = dm_tree_node_get_name(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1748,7 +1748,7 @@
 		/* If child has some real messages send them */
 		if ((child->props.send_messages > 1) && r) {
 			if (!(r = _node_send_messages(child, uuid_prefix, uuid_prefix_len, 1)))
-				stack;
+				log_stack;
 			else {
 				log_debug_activation("Sent messages to thin-pool %s and "
 						     "skipping suspend of its children.",
@@ -1779,7 +1779,7 @@
 			continue;
 
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1827,7 +1827,7 @@
 			continue;
 
 		if (!(sibling_name = dm_tree_node_get_name(sibling))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1856,7 +1856,7 @@
 	/* Activate children first */
 	while ((child = dm_tree_next_child(&handle, dnode, 0))) {
 		if (!(uuid = dm_tree_node_get_uuid(child))) {
-			stack;
+			log_stack;
 			continue;
 		}
 
@@ -1877,7 +1877,7 @@
 				continue;
 
 			if (!(uuid = dm_tree_node_get_uuid(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1885,7 +1885,7 @@
 				continue;
 
 			if (!(name = dm_tree_node_get_name(child))) {
-				stack;
+				log_stack;
 				continue;
 			}
 
@@ -1932,7 +1932,7 @@
 	 */
 	if (r && (dnode->props.send_messages > 1) &&
 	    !(r = _node_send_messages(dnode, uuid_prefix, uuid_prefix_len, 1)))
-		stack;
+		log_stack;
 
 	return r;
 }
@@ -2035,7 +2035,7 @@
 do {\
 	int w;\
 	if ((w = dm_snprintf(params + p, paramsize - (size_t) p, str)) < 0) {\
-		stack; /* Out of space */\
+		log_stack; /* Out of space */\
 		return -1;\
 	}\
 	p += w;\
@@ -2628,7 +2628,7 @@
 	case SEG_LINEAR:
 	case SEG_STRIPED:
 		if ((r = _emit_areas_line(dmt, seg, params, paramsize, &pos)) <= 0) {
-			stack;
+			log_stack;
 			return r;
 		}
 		if (!params[0]) {
@@ -2676,7 +2676,7 @@
 		dm_free(params);
 
 		if (!ret)
-			stack;
+			log_stack;
 
 		if (ret >= 0)
 			return ret;
@@ -2880,9 +2880,9 @@
 			/* When creating new node also check transaction_id. */
 			if (child->props.send_messages &&
 			    !_node_send_messages(child, uuid_prefix, uuid_prefix_len, 0)) {
-				stack;
+				log_stack;
 				if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-					stack;
+					log_stack;
 				dm_tree_set_cookie(dnode, 0);
 				(void) _dm_tree_revert_activated(dnode);
 				r = 0;
@@ -2902,7 +2902,7 @@
 	if (update_devs_flag ||
 	    (r && !dnode->info.exists && dnode->callback)) {
 		if (!dm_udev_wait(dm_tree_get_cookie(dnode)))
-			stack;
+			log_stack;
 		dm_tree_set_cookie(dnode, 0);
 
 		if (r && !dnode->info.exists && dnode->callback &&
diff -u -r ../src.orig/libdm/libdm-file.c ./libdm/libdm-file.c
--- ../src.orig/libdm/libdm-file.c	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/libdm-file.c	2020-08-03 10:42:36.061296597 +0200
@@ -251,12 +251,12 @@
                log_error("Cannot check lock status of lockfile [%s], error was [%s]",
                          lockfile, strerror(errno));
                if (close(fd))
-                       stack;
+                       log_stack;
                return 0;
        }
 
        if (close(fd))
-               stack;
+               log_stack;
 
        return (lock.l_type == F_UNLCK) ? 0 : 1;
 }
diff -u -r ../src.orig/libdm/libdm-report.c ./libdm/libdm-report.c
--- ../src.orig/libdm/libdm-report.c	2020-08-03 10:42:24.468850261 +0200
+++ ./libdm/libdm-report.c	2020-08-03 10:42:36.061296597 +0200
@@ -835,7 +835,7 @@
 	}
 
 	if (!_copy_field(rh, fp, field_num, implicit)) {
-		stack;
+		log_stack;
 		dm_pool_free(rh->mem, fp);
 		return NULL;
 	}
diff -u -r ../src.orig/libdm/libdm-stats.c ./libdm/libdm-stats.c
--- ../src.orig/libdm/libdm-stats.c	2020-08-03 10:42:24.468850261 +0200
+++ ./libdm/libdm-stats.c	2020-08-03 10:42:36.064631594 +0200
@@ -148,12 +148,12 @@
 	if (!fgets(buf, sizeof(buf), comm)) {
 		log_error("Could not read from %s", PROC_SELF_COMM);
 		if (fclose(comm))
-			stack;
+			log_stack;
 		return NULL;
 	}
 
 	if (fclose(comm))
-		stack;
+		log_stack;
 
 	return dm_strdup(buf);
 }
@@ -838,7 +838,7 @@
 			if (*c == *v)
 				break;
 		if (!*v) {
-			stack;
+			log_stack;
 			goto badchar;
 		}
 
@@ -862,7 +862,7 @@
 			if (*c == ',')
 				c++;
 			else if (*c || (*c == ' ')) { /* Expected ',' or NULL. */
-				stack;
+				log_stack;
 				goto badchar;
 			}
 
@@ -1078,13 +1078,13 @@
 	_stats_update_groups(dms);
 
 	if (fclose(list_rows))
-		stack;
+		log_stack;
 
 	return 1;
 
 bad:
 	if (fclose(list_rows))
-		stack;
+		log_stack;
 	dm_pool_abandon_object(mem);
 	dm_pool_abandon_object(group_mem);
 
@@ -1347,14 +1347,14 @@
 	region->counters = dm_pool_end_object(mem);
 
 	if (fclose(stats_rows))
-		stack;
+		log_stack;
 
 	return 1;
 
 bad:
 	if (stats_rows)
 		if (fclose(stats_rows))
-			stack;
+			log_stack;
 	dm_pool_abandon_object(mem);
 
 	return 0;
@@ -3539,7 +3539,7 @@
 				break;
 
 		if (!*v) {
-			stack;
+			log_stack;
 			goto badchar;
 		}
 
@@ -3569,14 +3569,14 @@
 				else if (*c == 'n')
 					mult = 1;
 				else {
-					stack;
+					log_stack;
 					goto badchar;
 				}
 				c += 2; /* Advance over 'ms', 'us', or 'ns'. */
 			} else if (*c == ',')
 				c++;
 			else if (*c) { /* Expected ',' or NULL. */
-				stack;
+				log_stack;
 				goto badchar;
 			}
 
@@ -3645,7 +3645,7 @@
 	if (bounds->dms || bounds->region) {
 		log_error("Freeing invalid histogram bounds pointer %p.",
 			  (void *) bounds);
-		stack;
+		log_stack;
 	}
 	/* dm_free() expects a (void *). */
 	dm_free((void *) bounds);
diff -u -r ../src.orig/libdm/libdm-timestamp.c ./libdm/libdm-timestamp.c
--- ../src.orig/libdm/libdm-timestamp.c	2020-08-03 10:42:24.468850261 +0200
+++ ./libdm/libdm-timestamp.c	2020-08-03 10:42:36.071301586 +0200
@@ -54,7 +54,7 @@
 	struct dm_timestamp *ts = NULL;
 
 	if (!(ts = dm_zalloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
@@ -102,7 +102,7 @@
 	struct dm_timestamp *ts;
 
 	if (!(ts = dm_malloc(sizeof(*ts))))
-		stack;
+		log_stack;
 
 	return ts;
 }
diff -u -r ../src.orig/libdm/regex/parse_rx.c ./libdm/regex/parse_rx.c
--- ../src.orig/libdm/regex/parse_rx.c	2020-08-03 10:42:24.465515266 +0200
+++ ./libdm/regex/parse_rx.c	2020-08-03 10:42:36.094646559 +0200
@@ -377,7 +377,7 @@
 		return l;
 
 	if (!(n = _node(ps->mem, CAT, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
@@ -400,7 +400,7 @@
 	}
 
 	if (!(n = _node(ps->mem, OR, l, r)))
-		stack;
+		log_stack;
 
 	return n;
 }
diff -u -r ../src.orig/tools/command.c ./tools/command.c
--- ../src.orig/tools/command.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/command.c	2020-08-03 10:42:37.198530255 +0200
@@ -708,7 +708,7 @@
 
 			if (!def->str) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return;
 			}
 		}
@@ -1448,7 +1448,7 @@
 
 			if (!cmd->name) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return 0;
 			}
 
@@ -1484,7 +1484,7 @@
 					cmd->desc = newdesc;
 				} else {
 					/* FIXME */
-					stack;
+					log_stack;
 					return 0;
 				}
 			} else
@@ -1507,7 +1507,7 @@
 
 			if (!cmd->command_id) {
 				/* FIXME */
-				stack;
+				log_stack;
 				return 0;
 			}
 			continue;
diff -u -r ../src.orig/tools/dumpconfig.c ./tools/dumpconfig.c
--- ../src.orig/tools/dumpconfig.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/dumpconfig.c	2020-08-03 10:42:37.205200248 +0200
@@ -331,7 +331,7 @@
 	}
 
 	if (!config_write(cft, &tree_spec, file, argc, argv)) {
-		stack;
+		log_stack;
 		r = ECMD_FAILED;
 	}
 out:
diff -u -r ../src.orig/tools/lvchange.c ./tools/lvchange.c
--- ../src.orig/tools/lvchange.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvchange.c	2020-08-03 10:42:37.215205237 +0200
@@ -400,7 +400,7 @@
 
 	if (!_vg_write_commit(lv, "intermediate")) {
 		if (!_reactivate_lv(lv, active, exclusive))
-			stack;
+			log_stack;
 		return 0;
 	}
 
diff -u -r ../src.orig/tools/lvconvert.c ./tools/lvconvert.c
--- ../src.orig/tools/lvconvert.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvconvert.c	2020-08-03 10:42:37.218540233 +0200
@@ -685,7 +685,7 @@
 
 	if (removed) {
 		if (!vg_write(vg) || !vg_commit(vg)) {
-			stack;
+			log_stack;
 			return;
 		}
 		log_warn("WARNING: %d missing and now unallocated Physical Volumes removed from VG.", removed);
@@ -2441,7 +2441,7 @@
 
 	/* Try to allocate new pool metadata spare LV */
 	if (!handle_pool_metadata_spare(pool_lv->vg, 0, pvh, poolmetadataspare))
-		stack;
+		log_stack;
 
 	if (dm_snprintf(meta_path, sizeof(meta_path), "%s_meta%%d", pool_lv->name) < 0) {
 		log_error("Can't prepare new metadata name for %s.", pool_lv->name);
@@ -2630,7 +2630,7 @@
 
 	/* Try to allocate new pool metadata spare LV */
 	if (!handle_pool_metadata_spare(cache_lv->vg, 0, pvh, poolmetadataspare))
-		stack;
+		log_stack;
 
 	if (dm_snprintf(meta_path, sizeof(meta_path), "%s_meta%%d", cache_lv->name) < 0) {
 		log_error("Can't prepare new metadata name for %s.", cache_lv->name);
@@ -2766,7 +2766,7 @@
 	 */
 
 	if (!swap_lv_identifiers(cmd, thin_lv, lv)) {
-		stack;
+		log_stack;
 		goto revert_new_lv;
 	}
 
@@ -2774,12 +2774,12 @@
 	thin_lv->status |= (lv->status & LVM_WRITE);
 
 	if (!attach_thin_external_origin(first_seg(thin_lv), lv)) {
-		stack;
+		log_stack;
 		goto revert_new_lv;
 	}
 
 	if (!lv_update_and_reload(thin_lv)) {
-		stack;
+		log_stack;
 		goto deactivate_and_revert_new_lv;
 	}
 
@@ -2790,7 +2790,7 @@
 
 deactivate_and_revert_new_lv:
 	if (!swap_lv_identifiers(cmd, thin_lv, lv))
-		stack;
+		log_stack;
 
 	if (!deactivate_lv(cmd, thin_lv)) {
 		log_error("Unable to deactivate failed new LV. "
diff -u -r ../src.orig/tools/lvconvert_poll.c ./tools/lvconvert_poll.c
--- ../src.orig/tools/lvconvert_poll.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvconvert_poll.c	2020-08-03 10:42:37.218540233 +0200
@@ -177,7 +177,7 @@
 	uint32_t device_id;
 
 	if (!lv_thin_device_id(lv, &device_id)) {
-		stack;
+		log_stack;
 		return PROGRESS_CHECK_FAILED;
 	}
 
diff -u -r ../src.orig/tools/lvcreate.c ./tools/lvcreate.c
--- ../src.orig/tools/lvcreate.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvcreate.c	2020-08-03 10:42:37.221875228 +0200
@@ -1760,12 +1760,12 @@
 	int ret;
 
 	if (!_lvcreate_params(cmd, argc, argv, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
 	if (!_check_pool_parameters(cmd, NULL, &lp, &lcp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../src.orig/tools/lvm.c ./tools/lvm.c
--- ../src.orig/tools/lvm.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvm.c	2020-08-03 10:42:37.228545220 +0200
@@ -336,7 +336,7 @@
 
 	if (cmd->cmd_report.report_group) {
 		if (!dm_report_group_destroy(cmd->cmd_report.report_group))
-			stack;
+			log_stack;
 		cmd->cmd_report.report_group = NULL;
 	}
 
diff -u -r ../src.orig/tools/lvmcmdline.c ./tools/lvmcmdline.c
--- ../src.orig/tools/lvmcmdline.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvmcmdline.c	2020-08-03 10:42:37.241885205 +0200
@@ -3064,7 +3064,7 @@
 
 	if ((ret = _process_common_commands(cmd))) {
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		goto out;
 	}
 
@@ -3151,10 +3151,10 @@
 	if (config_string_cft) {
 		/* Move this? */
 		if (!refresh_toolcontext(cmd))
-			stack;
+			log_stack;
 	} else if (config_profile_command_cft || config_profile_metadata_cft) {
 		if (!process_profilable_config(cmd))
-			stack;
+			log_stack;
 	}
 
 	if (ret == EINVALID_CMD_LINE && !cmd->is_interactive)
@@ -3429,7 +3429,7 @@
 	struct cmd_context *cmd;
 
 	if (!udev_init_library_context())
-		stack;
+		log_stack;
 
 	/*
 	 * It's not necessary to use name mangling for LVM:
diff -u -r ../src.orig/tools/lvrename.c ./tools/lvrename.c
--- ../src.orig/tools/lvrename.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvrename.c	2020-08-03 10:42:37.248555198 +0200
@@ -187,7 +187,7 @@
 	}
 
 	if (!apply_lvname_restrictions(lv_name_new)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../src.orig/tools/lvresize.c ./tools/lvresize.c
--- ../src.orig/tools/lvresize.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/lvresize.c	2020-08-03 10:42:37.251890193 +0200
@@ -190,7 +190,7 @@
 	int ret;
 
 	if (!_lvresize_params(cmd, argc, argv, &lp)) {
-		stack;
+		log_stack;
 		return EINVALID_CMD_LINE;
 	}
 
diff -u -r ../src.orig/tools/polldaemon.c ./tools/polldaemon.c
--- ../src.orig/tools/polldaemon.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/polldaemon.c	2020-08-03 10:42:37.255225190 +0200
@@ -213,7 +213,7 @@
 		unlock_and_release_vg(cmd, vg, vg->name);
 
 		if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		/*
 		 * FIXME Sleeping after testing, while preferred, also works around
@@ -237,7 +237,7 @@
 	if (vg)
 		unlock_and_release_vg(cmd, vg, vg->name);
 	if (!lockd_vg(cmd, id->vg_name, "un", 0, &lockd_state))
-		stack;
+		log_stack;
 
 	return ret;
 }
@@ -611,7 +611,7 @@
 
 	if (id) {
 		if (!wait_for_single_lv(cmd, id, parms)) {
-			stack;
+			log_stack;
 			ret = ECMD_FAILED;
 		}
 	} else {
diff -u -r ../src.orig/tools/pvck.c ./tools/pvck.c
--- ../src.orig/tools/pvck.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/pvck.c	2020-08-03 10:42:37.258560186 +0200
@@ -307,7 +307,7 @@
 	uint64_t mda2_offset;
 
 	if (dev_get_size(dev, &dev_sectors))
-		stack;
+		log_stack;
 
 	dev_bytes = dev_sectors * 512;
 	extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -328,7 +328,7 @@
 	uint64_t mda2_size;
 
 	if (dev_get_size(dev, &dev_sectors))
-		stack;
+		log_stack;
 
 	dev_bytes = dev_sectors * 512;
 	extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -639,9 +639,9 @@
 
 	if (fp) {
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 
 	return 1;
@@ -871,9 +871,9 @@
 	free(meta_buf);
 
 	if (fflush(fp))
-		stack;
+		log_stack;
 	if (fclose(fp))
-		stack;
+		log_stack;
 	return 1;
 }
 
@@ -988,9 +988,9 @@
 		fprintf(fp, "%s", meta_buf);
 
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 
  out:
@@ -1039,7 +1039,7 @@
 	 * a larger range that overlaps this.
 	 */
 	if (dev && !dev_invalidate_bytes(dev, lh_offset, 512))
-		stack;
+		log_stack;
 
 	lh = (struct label_header *)buf;
 
@@ -1700,7 +1700,7 @@
 		uint64_t extra_bytes;
 
 		if (dev_get_size(dev, &dev_sectors))
-			stack;
+			log_stack;
 
 		dev_bytes = dev_sectors * 512;
 		extra_bytes = dev_bytes % ONE_MB_IN_BYTES;
@@ -2834,7 +2834,7 @@
 	}
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	if (!_is_backup_file(cmd, back_buf, back_size)) {
 		log_error("File does not appear to contain a metadata backup.");
@@ -2862,9 +2862,9 @@
 		fprintf(fp, "%s", text_buf);
 
 		if (fflush(fp))
-			stack;
+			log_stack;
 		if (fclose(fp))
-			stack;
+			log_stack;
 	}
 	ret = 1;
 out:
@@ -2874,7 +2874,7 @@
 
 fail_close:
 	if (close(fd))
-		stack;
+		log_stack;
 	return 0;
 }
 
@@ -2973,7 +2973,7 @@
 	text_size += 1; /* null terminating byte */
 
 	if (close(fd))
-		stack;
+		log_stack;
 
 	if (_is_backup_file(cmd, text_buf, text_size)) {
 		char *back_buf = text_buf;
@@ -3001,7 +3001,7 @@
 
 out:
 	if (close(fd))
-		stack;
+		log_stack;
 	return 0;
 }
 
diff -u -r ../src.orig/tools/pvmove.c ./tools/pvmove.c
--- ../src.orig/tools/pvmove.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/pvmove.c	2020-08-03 10:42:37.265230178 +0200
@@ -527,7 +527,7 @@
 	r = activate_lv(cmd, lv_mirr);
 
 	if (!r)
-		stack;
+		log_stack;
 
 	return r;
 }
@@ -893,12 +893,12 @@
 
 		if (!is_abort) {
 			if (!pp.found_pv) {
-				stack;
+				log_stack;
 				return EINVALID_CMD_LINE;
 			}
 
 			if (pp.setup_result != ECMD_PROCESSED) {
-				stack;
+				log_stack;
 				return pp.setup_result;
 			}
 		} else {
diff -u -r ../src.orig/tools/pvscan.c ./tools/pvscan.c
--- ../src.orig/tools/pvscan.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/pvscan.c	2020-08-03 10:42:37.271900170 +0200
@@ -72,7 +72,7 @@
 
 	if (arg_is_set(cmd, uuid_ARG)) {
 		if (!id_write_format(&pv->id, uuid, sizeof(uuid))) {
-			stack;
+			log_stack;
 			return ECMD_FAILED;
 		}
 
@@ -554,7 +554,7 @@
 	if (!dev_args || dev_args_in_vg) {
 		log_debug("online dev %s can autoactivate VG %s", dev_name(dev), vg->name);
 		if (!str_list_add(cmd->mem, found_vgnames, dm_pool_strdup(cmd->mem, vg->name)))
-			stack;
+			log_stack;
 	}
 
 	return 1;
@@ -789,7 +789,7 @@
 		if (!pvids_not_online) {
 			log_debug("pvid %s makes complete VG %s", pvid, vg->name);
 			if (!str_list_add(cmd->mem, found_vgnames, dm_pool_strdup(cmd->mem, vg->name)))
-				stack;
+				log_stack;
 		} else
 			log_debug("pvid %s incomplete VG %s", pvid, vg->name);
 		break;
@@ -829,14 +829,14 @@
 
 	while ((dev = dev_iter_get(cmd, iter))) {
 		if (sigint_caught()) {
-			stack;
+			log_stack;
 			break;
 		}
 
 		pvid_without_metadata = NULL;
 
 		if (!_online_pvscan_one(cmd, dev, dev_args, found_vgnames, saved_vgs, 1, &pvid_without_metadata)) {
-			stack;
+			log_stack;
 			break;
 		}
 
@@ -1480,7 +1480,7 @@
 		release_vg(vgl->vg);
 
 	if (!sync_local_dev_names(cmd))
-		stack;
+		log_stack;
 	return ret;
 }
 
diff -u -r ../src.orig/tools/reporter.c ./tools/reporter.c
--- ../src.orig/tools/reporter.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/reporter.c	2020-08-03 10:42:37.275235166 +0200
@@ -1186,7 +1186,7 @@
 out:
 	if (report_handle) {
 		if (report_in_group && !dm_report_group_pop(cmd->cmd_report.report_group))
-			stack;
+			log_stack;
 		dm_report_free(report_handle);
 	}
 
@@ -1214,14 +1214,14 @@
 	if (orphan) {
 		if (((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVSEGS])) != ECMD_PROCESSED))
-			stack;
+			log_stack;
 	} else {
 		if (((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_VGS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_LVS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_PVSEGS])) != ECMD_PROCESSED) ||
 		    ((r = _do_report(cmd, handle, args, &args->single_args[REPORT_IDX_FULL_SEGS])) != ECMD_PROCESSED))
-			stack;
+			log_stack;
 	}
 
 	if (!args->log_only && !dm_report_group_pop(cmd->cmd_report.report_group))
@@ -1525,7 +1525,7 @@
 	return 1;
 bad:
 	if (!dm_report_group_destroy(new_report_group))
-		stack;
+		log_stack;
 	if (tmp_log_rh)
 		dm_report_free(tmp_log_rh);
 	return 0;
diff -u -r ../src.orig/tools/toollib.c ./tools/toollib.c
--- ../src.orig/tools/toollib.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/toollib.c	2020-08-03 10:42:37.285240153 +0200
@@ -328,7 +328,7 @@
 	if (dm_list_empty(&pv->segments)) {
 		ret = process_single_pvseg(cmd, NULL, &_free_pv_segment, handle);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		if (ret > ret_max)
 			ret_max = ret;
 	} else {
@@ -339,7 +339,7 @@
 			ret = process_single_pvseg(cmd, vg, pvseg, handle);
 			_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			if (ret > ret_max)
 				ret_max = ret;
 		}
@@ -367,7 +367,7 @@
 		ret = process_single_seg(cmd, seg, handle);
 		_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		if (ret > ret_max)
 			ret_max = ret;
 	}
@@ -1097,13 +1097,13 @@
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		if (sigint_caught()) {
 			r = 0;
-			stack;
+			log_stack;
 			break;
 		}
 
 		if (lv_is_visible(lvl->lv) && !lv_refresh(cmd, lvl->lv)) {
 			r = 0;
-			stack;
+			log_stack;
 		}
 	}
 
@@ -1848,7 +1848,7 @@
 
 		if (!cmd->is_interactive) {
 			if (!dm_report_group_destroy(cmd->cmd_report.report_group))
-				stack;
+				log_stack;
 			cmd->cmd_report.report_group = NULL;
 
 			if (cmd->cmd_report.log_rh) {
@@ -1968,7 +1968,7 @@
 			log_set_report_object_name_and_id(vg_name + sizeof(VG_ORPHANS), uuid);
 		} else {
 			if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			log_set_report_object_name_and_id(vg_name, uuid);
 		}
 
@@ -1980,7 +1980,7 @@
 		log_very_verbose("Processing VG %s %s", vg_name, uuid);
 
 		if (!lockd_vg(cmd, vg_name, NULL, 0, &lockd_state)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			continue;
@@ -1988,7 +1988,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, arg_vgnames, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (error_vg)
@@ -2012,7 +2012,7 @@
 			ret = process_single_vg(cmd, vg_name, vg, handle);
 			_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			report_log_ret_code(ret);
 			if (ret > ret_max)
 				ret_max = ret;
@@ -2022,7 +2022,7 @@
 endvg:
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(NULL, NULL);
 	}
@@ -2081,7 +2081,7 @@
 			 */
 			if (lvmcache_vg_is_foreign(cmd, vgnl->vg_name, vgnl->vgid)) {
 				if (!id_write_format((const struct id*)vgnl->vgid, uuid, sizeof(uuid)))
-					stack;
+					log_stack;
 				log_warn("WARNING: Ignoring foreign VG with matching name %s UUID %s.",
 					 vgnl->vg_name, uuid);
 				dm_list_del(&vgnl->list);
@@ -3032,7 +3032,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	dm_list_init(&final_lvs);
 	dm_list_init(&found_arg_lvnames);
@@ -3065,7 +3065,7 @@
 	dm_list_iterate_items(lvl, &vg->lvs) {
 		lv_uuid[0] = '\0';
 		if (!id_write_format(&lvl->lv->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(lvl->lv->name, lv_uuid);
 
@@ -3169,7 +3169,7 @@
 	dm_list_iterate_items(lvl, &final_lvs) {
 		lv_uuid[0] = '\0';
 		if (!id_write_format(&lvl->lv->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(lvl->lv->name, lv_uuid);
 
@@ -3224,7 +3224,7 @@
 		if (handle_supplied)
 			_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
@@ -3244,7 +3244,7 @@
 		dm_list_iterate_items_safe(glvl, tglvl, &vg->historical_lvs) {
 			lv_uuid[0] = '\0';
 			if (!id_write_format(&glvl->glv->historical->lvid.id[1], lv_uuid, sizeof(lv_uuid)))
-				stack;
+				log_stack;
 
 			log_set_report_object_name_and_id(glvl->glv->historical->name, lv_uuid);
 
@@ -3275,7 +3275,7 @@
 			if (handle_supplied)
 				_update_selection_result(handle, &whole_selected);
 			if (ret != ECMD_PROCESSED)
-				stack;
+				log_stack;
 			report_log_ret_code(ret);
 			if (ret > ret_max)
 				ret_max = ret;
@@ -3408,7 +3408,7 @@
 				lv_name++;
 			if (!(vgname = extract_vgname(cmd, vgname))) {
 				if (ret_max < ECMD_FAILED) {
-					stack;
+					log_stack;
 					ret_max = ECMD_FAILED;
 				}
 				continue;
@@ -3625,7 +3625,7 @@
 
 		uuid[0] = '\0';
 		if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(vg_name, uuid);
 
@@ -3675,7 +3675,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, arg_vgnames, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (error_vg)
@@ -3691,7 +3691,7 @@
 		ret = process_each_lv_in_vg(cmd, vg, &lvnames, tags_arg, 0,
 					    handle, check_single_lv, process_single_lv);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
@@ -3700,7 +3700,7 @@
 endvg:
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 		log_set_report_object_name_and_id(NULL, NULL);
 	}
 	do_report_ret_code = 0;
@@ -4186,7 +4186,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	if (!handle && (!(handle = init_processing_handle(cmd, NULL)))) {
 		ret_max = ECMD_FAILED;
@@ -4207,7 +4207,7 @@
 		pv_name = pv_dev_name(pv);
 		pv_uuid[0]='\0';
 		if (!id_write_format(&pv->id, pv_uuid, sizeof(pv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(pv_name, pv_uuid);
 
@@ -4274,7 +4274,7 @@
 			if (!skip) {
 				ret = process_single_pv(cmd, vg, pv, handle);
 				if (ret != ECMD_PROCESSED)
-					stack;
+					log_stack;
 				report_log_ret_code(ret);
 				if (ret > ret_max)
 					ret_max = ret;
@@ -4358,7 +4358,7 @@
 			log_set_report_object_name_and_id(vg_name + sizeof(VG_ORPHANS), uuid);
 		} else {
 			if (vg_uuid && !id_write_format((const struct id*)vg_uuid, uuid, sizeof(uuid)))
-				stack;
+				log_stack;
 			log_set_report_object_name_and_id(vg_name, uuid);
 		}
 
@@ -4379,7 +4379,7 @@
 
 		vg = vg_read(cmd, vg_name, vg_uuid, read_flags, lockd_state, &error_flags, &error_vg);
 		if (_ignore_vg(cmd, error_flags, error_vg, vg_name, NULL, read_flags, &skip, &notfound)) {
-			stack;
+			log_stack;
 			ret_max = ECMD_FAILED;
 			report_log_ret_code(ret_max);
 			if (!skip)
@@ -4398,7 +4398,7 @@
 					 process_all_pvs, process_all_devices, skip, error_flags,
 					 handle, process_single_pv);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 
 		report_log_ret_code(ret);
 
@@ -4412,7 +4412,7 @@
 			unlock_and_release_vg(cmd, error_vg, vg_name);
 		release_vg(vg);
 		if (!lockd_vg(cmd, vg_name, "un", 0, &lockd_state))
-			stack;
+			log_stack;
 
 		/* Quit early when possible. */
 		if (!process_all_pvs && dm_list_empty(arg_tags) && dm_list_empty(arg_devices)) {
@@ -4528,7 +4528,7 @@
 				  process_all_pvs, process_all_devices,
 				  handle, process_single_pv);
 	if (ret != ECMD_PROCESSED)
-		stack;
+		log_stack;
 	if (ret > ret_max)
 		ret_max = ret;
 
@@ -4568,7 +4568,7 @@
 	ret = _process_duplicate_pvs(cmd, &all_devices, &arg_devices, process_all_devices,
 				     handle, process_single_pv);
 	if (ret != ECMD_PROCESSED)
-		stack;
+		log_stack;
 	if (ret > ret_max)
 		ret_max = ret;
 
@@ -4582,7 +4582,7 @@
 
 	ret = _process_device_list(cmd, &all_devices, handle, process_single_pv);
 	if (ret != ECMD_PROCESSED)
-		stack;
+		log_stack;
 	if (ret > ret_max)
 		ret_max = ret;
 out:
@@ -4607,7 +4607,7 @@
 
 	vg_uuid[0] = '\0';
 	if (!id_write_format(&vg->id, vg_uuid, sizeof(vg_uuid)))
-		stack;
+		log_stack;
 
 	if (!is_orphan_vg(vg->name))
 		log_set_report_object_group_and_group_id(vg->name, vg_uuid);
@@ -4615,7 +4615,7 @@
 	dm_list_iterate_items(pvl, &vg->pvs) {
 		pv_uuid[0] = '\0';
 		if (!id_write_format(&pvl->pv->id, pv_uuid, sizeof(pv_uuid)))
-			stack;
+			log_stack;
 
 		log_set_report_object_name_and_id(pv_dev_name(pvl->pv), pv_uuid);
 
@@ -4627,7 +4627,7 @@
 		ret = process_single_pv(cmd, vg, pvl->pv, handle);
 		_update_selection_result(handle, &whole_selected);
 		if (ret != ECMD_PROCESSED)
-			stack;
+			log_stack;
 		report_log_ret_code(ret);
 		if (ret > ret_max)
 			ret_max = ret;
diff -u -r ../src.orig/tools/vgchange.c ./tools/vgchange.c
--- ../src.orig/tools/vgchange.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/vgchange.c	2020-08-03 10:42:37.295245143 +0200
@@ -120,7 +120,7 @@
 		expected_count++;
 
 		if (!lv_change_activate(cmd, lv, activate)) {
-			stack;
+			log_stack;
 			r = 0;
 			continue;
 		}
@@ -143,7 +143,7 @@
 	 */
 	if (count && is_change_activating(activate) &&
 	    !vgchange_background_polling(cmd, vg)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -253,7 +253,7 @@
 	}
 
 	if (!_activate_lvs_in_vg(cmd, vg, activate)) {
-		stack;
+		log_stack;
 		r = 0;
 	}
 
@@ -1144,7 +1144,7 @@
 		const char *start_opt = arg_str_value(cmd, lockopt_ARG, NULL);
 
 		if (!lockd_global(cmd, "un"))
-			stack;
+			log_stack;
 
 		if (!start_opt || !strcmp(start_opt, "auto")) {
 			if (vp.lock_start_sanlock)
diff -u -r ../src.orig/tools/vgremove.c ./tools/vgremove.c
--- ../src.orig/tools/vgremove.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/vgremove.c	2020-08-03 10:42:37.315255119 +0200
@@ -60,7 +60,7 @@
 
 		if ((ret = process_each_lv_in_vg(cmd, vg, NULL, NULL, 1, &void_handle,
 						 NULL, (process_single_lv_fn_t)lvremove_single)) != ECMD_PROCESSED) {
-			stack;
+			log_stack;
 			return ret;
 		}
 	}
diff -u -r ../src.orig/tools/vgrename.c ./tools/vgrename.c
--- ../src.orig/tools/vgrename.c	2020-08-03 10:42:24.445505289 +0200
+++ ./tools/vgrename.c	2020-08-03 10:42:37.315255119 +0200
@@ -107,7 +107,7 @@
 		goto error;
 
 	if (!lockd_rename_vg_before(cmd, vg)) {
-		stack;
+		log_stack;
 		goto error;
 	}
 
@@ -145,9 +145,9 @@
 	lockd_rename_vg_final(cmd, vg, 1);
 
 	if (!backup(vg))
-		stack;
+		log_stack;
 	if (!backup_remove(cmd, vg_name))
-		stack;
+		log_stack;
 
 	unlock_vg(cmd, vg, vp->vg_name_new);
 	vp->unlock_new_name = 0;
